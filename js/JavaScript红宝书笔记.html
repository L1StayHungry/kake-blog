<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>一、介绍 | 卡克</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="卡克的个人博客">
    
    <link rel="preload" href="/kake-blog/assets/css/0.styles.060b3ec1.css" as="style"><link rel="preload" href="/kake-blog/assets/js/app.ba41769d.js" as="script"><link rel="preload" href="/kake-blog/assets/js/3.e126f458.js" as="script"><link rel="preload" href="/kake-blog/assets/js/1.f474e8b5.js" as="script"><link rel="preload" href="/kake-blog/assets/js/16.3ad6af45.js" as="script"><link rel="prefetch" href="/kake-blog/assets/js/10.ab56f7dd.js"><link rel="prefetch" href="/kake-blog/assets/js/11.22ef5694.js"><link rel="prefetch" href="/kake-blog/assets/js/12.fdcf5344.js"><link rel="prefetch" href="/kake-blog/assets/js/13.9b393b1b.js"><link rel="prefetch" href="/kake-blog/assets/js/14.0ddd8852.js"><link rel="prefetch" href="/kake-blog/assets/js/15.4ad49071.js"><link rel="prefetch" href="/kake-blog/assets/js/17.90ce0ea5.js"><link rel="prefetch" href="/kake-blog/assets/js/18.857c4fed.js"><link rel="prefetch" href="/kake-blog/assets/js/19.3ca5fe1c.js"><link rel="prefetch" href="/kake-blog/assets/js/20.5299e0fe.js"><link rel="prefetch" href="/kake-blog/assets/js/21.5028024e.js"><link rel="prefetch" href="/kake-blog/assets/js/22.b38bf968.js"><link rel="prefetch" href="/kake-blog/assets/js/23.cb1f4fd3.js"><link rel="prefetch" href="/kake-blog/assets/js/24.c4bcad1f.js"><link rel="prefetch" href="/kake-blog/assets/js/25.71a6043d.js"><link rel="prefetch" href="/kake-blog/assets/js/26.b3fd8499.js"><link rel="prefetch" href="/kake-blog/assets/js/27.8ca4bb9d.js"><link rel="prefetch" href="/kake-blog/assets/js/28.d9c67b40.js"><link rel="prefetch" href="/kake-blog/assets/js/29.07ed6977.js"><link rel="prefetch" href="/kake-blog/assets/js/4.90ac1a62.js"><link rel="prefetch" href="/kake-blog/assets/js/5.3b7e8ac1.js"><link rel="prefetch" href="/kake-blog/assets/js/6.81544bb5.js"><link rel="prefetch" href="/kake-blog/assets/js/7.5104c8ec.js"><link rel="prefetch" href="/kake-blog/assets/js/8.46dbe6e0.js"><link rel="prefetch" href="/kake-blog/assets/js/9.247a4459.js">
    <link rel="stylesheet" href="/kake-blog/assets/css/0.styles.060b3ec1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>卡克</h3> <p class="description" data-v-59e6cb88>卡克的个人博客</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/kake-blog/" class="home-link router-link-active"><!----> <span class="site-name">卡克</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/kake-blog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      卡克的 前端博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/L1StayHungry" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><!----> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>20</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>0</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/kake-blog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      卡克的 前端博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/L1StayHungry" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/kake-blog/" class="sidebar-heading clickable router-link-active"><span>好好学习，天天向上</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/kake-blog/" aria-current="page" class="sidebar-link">学前必读</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/kake-blog/js/JavaScript红宝书笔记" class="sidebar-heading clickable open active"><span>JS整理</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/kake-blog/js/JavaScript红宝书笔记.html" class="active sidebar-link">JavaScript红宝书笔记</a></li><li><a href="/kake-blog/js/原型和原型链.html" class="sidebar-link">原型和原型链</a></li><li><a href="/kake-blog/js/PromiseA+.html" class="sidebar-link">PromiseA+规范</a></li><li><a href="/kake-blog/js/实现一个Promise.html" class="sidebar-link">实现一个Promise</a></li><li><a href="/kake-blog/js/generator &amp; async await.html" class="sidebar-link">generator &amp; async await</a></li><li><a href="/kake-blog/js/变量_作用域_内存.html" class="sidebar-link">变量_作用域_内存</a></li><li><a href="/kake-blog/js/js模块化.html" class="sidebar-link">js模块化</a></li><li><a href="/kake-blog/js/数组相关.html" class="sidebar-link">数组相关</a></li><li><a href="/kake-blog/js/BOM.html" class="sidebar-link">BOM相关</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/kake-blog/css/CSS" class="sidebar-heading clickable"><span>CSS整理</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/kake-blog/html/H5" class="sidebar-heading clickable"><span>HTML整理</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/kake-blog/vue2/vue知识点" class="sidebar-heading clickable"><span>vue2</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/kake-blog/browser/浏览器相关" class="sidebar-heading clickable"><span>浏览器相关</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/kake-blog/进阶/常见算法" class="sidebar-heading clickable"><span>进阶</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88></h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">一、介绍</h1> <div data-v-8a445198><!----> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h3 id="一、介绍"><a href="#一、介绍" class="header-anchor">#</a> 一、介绍</h3> <h4 id="历史"><a href="#历史" class="header-anchor">#</a> 历史</h4> <ol><li>1995年问世，网景公司、sun。代替Perl等服务器语言处理输入验证。</li> <li>微软的Jscript,网景的NetScape Navigator中的JavaScript</li> <li>1997年，ECMA-262标准。98年，ISO、IEC采纳</li></ol> <h4 id="实现"><a href="#实现" class="header-anchor">#</a> 实现</h4> <ol><li>核心：ECMAScript
<ol><li>宿主环境：浏览器、nodejs、AdobeFlash(淘汰)</li> <li>定义了：
<ul><li>语法</li> <li>类型</li> <li>语句</li> <li>关键字</li> <li>保留字</li> <li>操作符</li> <li>全局对象</li></ul></li> <li>版本：
<ul><li>ECMA-262 (第3版)，字符串处理、错误定义、数值输出、正则表达式、try/catch等，标志着ECMAScript作为以吗真正的编程语言</li> <li>2009，ECMAScript 3.1 (第5版)。JSON对象等</li> <li>2015，ES6,类、模块、迭代器、生成器、箭头函数、期约、反射、代理、新数据类型等</li> <li>2017，ES8,异步(async/await)等</li></ul></li></ol></li> <li>文档对象模型DOM
<ol><li>本质：应用编程接口，用于在HTML中使用扩展的XML</li> <li>DOM级别：
<ul><li>98年，DOM Level1成为W3C推荐标准，映射文档结构</li> <li>DOM Level 2 : DOM视图、DOM事件、DOM样式、DOM遍历和范围</li> <li>Level 3 ： 统一的方式加载和保存文档、验证文档的方法</li></ul></li></ol></li> <li>浏览器对象模型BOM
<ol><li>用于支持访问和操作浏览器的窗口、子窗口（frame）</li> <li>H5的出现，BOM才开始标准化
<ul><li>新弹窗</li> <li>移动、缩放、关闭窗口</li> <li>navigator对象，浏览器信息</li> <li>location对象，浏览器加载页面信息</li> <li>screen对象，屏幕信息</li> <li>performance对象，内容、导航、时间统计等信息</li> <li>cookie支持</li> <li>其他，如XMLHttpRequest</li></ul></li></ol></li></ol> <h4 id="es6"><a href="#es6" class="header-anchor">#</a> ES6</h4> <ul><li>模板字面量---使用<code>我是字符串</code>反引号定义字符串</li> <li>symbol符号，ES6新增</li> <li>Map、weakMap</li> <li>Set、weakSet</li> <li>Object.is( )   (和===类似，但更完善)</li> <li>对象解构</li> <li>代理与反射</li> <li>箭头函数</li> <li>函数实现默认参数值</li> <li>Promise/A+</li> <li>async/await(es8)</li> <li>ES6 最大的一个改进就是引入了<strong>模块</strong>规范。</li> <li>ECMAScript 2018 于 2018 年 1 月完成，主要增加了异步迭代、剩余和扩展操作符、正则表达式和期 约等方面的特性。</li></ul> <h3 id="二、html中的js"><a href="#二、html中的js" class="header-anchor">#</a> 二、HTML中的Js</h3> <h4 id="script-元素"><a href="#script-元素" class="header-anchor">#</a> &lt; script /&gt;元素</h4> <p>属性：</p> <ol><li><strong>async ：立即开始下载脚本但不阻止其他页面动作，只对外部脚本文件有效。不保证下载顺序。HTML5开始</strong>.异步脚本不应该在加载期间修改DOM</li> <li>charset : 使用src属性指定的代码字符集</li> <li>crossorigin : 配置相关请求的CORS设置。默认不使用CORS.</li> <li><strong>defer : 脚本可以延迟文档完全解析显示后再执行，只对外部脚本有效（HTML 4.01）。保证下载顺序</strong></li> <li>integrity</li> <li>src , 包含要执行的代码的外部文件</li> <li>type : 表示代码块中脚本语言的内容类型：text/javascript</li></ol> <p>注意点：</p> <ol><li>&lt; script &gt;元素的强大又被争议的点：可以包含来自外部域的Js。GET请求获取资源。初始的i请求不受浏览器同源策略限制，但返回并被执行的Js则受限制。</li></ol> <p>位置：&lt; body &gt;元素中的页面内容后面</p> <h4 id="行内代码or外部文件"><a href="#行内代码or外部文件" class="header-anchor">#</a> 行内代码or外部文件？</h4> <p>尽可能将js代码放在外部文件中</p> <ol><li>可维护性强</li> <li>缓存。被重复引用的js文件只需下载一次。</li></ol> <h4 id="js合并-no"><a href="#js合并-no" class="header-anchor">#</a> Js合并？no</h4> <div class="language- extra-class"><pre><code>   在配置浏览器请求外部文件时，要重点考虑的一点是它们会占用多少带宽。在 SPDY/HTTP2 中， **预请求**的消耗已显著降低，以轻量、独立 JavaScript 组件形式向客户端送达脚本更具优势。
</code></pre></div><h4 id="文档模式"><a href="#文档模式" class="header-anchor">#</a> 文档模式</h4> <p>通过doctype切换</p> <ul><li>混杂模式（quirks mode）</li> <li>标准模式（standards mode）</li> <li>准标准模式（almost standards mode）: 主要区别在于如何对待图片元素周围的空白（在表格中使用图片时最明显）。</li></ul> <h4 id="noscript"><a href="#noscript" class="header-anchor">#</a> &lt; noscript &gt;</h4> <ul><li>早期：早期部分浏览器不支持js, <strong>优雅降级</strong></li> <li>现在：浏览器对脚本的支持被关闭时，显示。</li></ul> <h3 id="三、语言基础"><a href="#三、语言基础" class="header-anchor">#</a> 三、语言基础</h3> <h4 id="语法"><a href="#语法" class="header-anchor">#</a> 语法</h4> <ul><li><p>区分大小写。</p></li> <li><p>严格模式。ES5添加的。</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>//启用严格模式
use strict;
</code></pre></div><ul><li>关键字/保留字</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code>关键字：不能作为标识符和属性名
<span class="token keyword">break</span>     <span class="token keyword">do</span>        <span class="token keyword">in</span>            <span class="token keyword">typeof</span>
<span class="token keyword">case</span>      <span class="token keyword">else</span>      <span class="token keyword">instanceof</span>    <span class="token class-name">var</span>
<span class="token keyword">catch</span>     <span class="token keyword">export</span>    <span class="token keyword">new</span>           <span class="token class-name">void</span>
<span class="token keyword">class</span>     <span class="token class-name">extends</span>   <span class="token keyword">return</span>        <span class="token keyword">while</span>
<span class="token keyword">const</span>     finally   <span class="token keyword">super</span>         <span class="token keyword">with</span>
<span class="token keyword">continue</span>  <span class="token keyword">for</span>       <span class="token keyword">switch</span>        <span class="token keyword">yield</span>
<span class="token keyword">debugger</span>  <span class="token keyword">function</span>  <span class="token keyword">this</span>
<span class="token keyword">default</span>   <span class="token keyword">if</span>        <span class="token keyword">throw</span>
<span class="token keyword">delete</span>    <span class="token keyword">import</span>    <span class="token keyword">try</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token literal-property property">保留字</span><span class="token operator">:</span>不能作为标识符但可以作为属性名
始终保留：
<span class="token keyword">enum</span>
<span class="token literal-property property">严格模式下保留</span><span class="token operator">:</span>
<span class="token keyword">implements</span>    <span class="token class-name">interface</span>    <span class="token keyword">let</span>
<span class="token keyword">package</span>       <span class="token keyword">protected</span>    <span class="token keyword">private</span>
<span class="token keyword">public</span>        <span class="token keyword">static</span>
模块代码中保留
<span class="token keyword">await</span>
</code></pre></div><ul><li>变量： var let (const) 。let和const为ES6及之后版本可使用。<strong>var是函数作用域，let是块作用域。</strong> <ul><li>在函数内，定义变量但是省略了var操作符时，会创建一个全局变量（局部作用域中的全局变量）。<strong>严格模式下禁止</strong>，抛出ReferenceError。</li> <li><strong>var声明提升</strong>。变量的<strong>声明</strong>被提升到了作用域的顶部</li> <li>全局声明。全局作用域中声明的变量，let不会成为window对象的属性，var会</li></ul></li></ul> <h4 id="数据类型"><a href="#数据类型" class="header-anchor">#</a> 数据类型</h4> <ul><li><p>基本数据类型</p> <ul><li>undefined。值未定义。</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// undefined是由null派生出来的</span>
<span class="token keyword">null</span> <span class="token operator">==</span> <span class="token keyword">undefined</span>  <span class="token comment">// true</span>
<span class="token comment">// ==操作符会为了比较二转换它的操作数</span>
</code></pre></div><ul><li>null。空对象指针。</li> <li>number数值。双精度。</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 默认十进制</span>

<span class="token comment">// 八进制（严格模式下无效）</span>
<span class="token keyword">let</span> octalNum1 <span class="token operator">=</span> <span class="token number">070</span> <span class="token comment">// 八进制的56</span>
<span class="token keyword">let</span> octalNUm3 <span class="token operator">=</span> <span class="token number">08</span> <span class="token comment">// 无效，当成8处理</span>

<span class="token comment">// 十六进制 前缀0x(零·)</span>
<span class="token keyword">let</span> hexNum1 <span class="token operator">=</span> <span class="token number">0xA</span><span class="token punctuation">;</span> <span class="token comment">// 10</span>

小数点后面如果没有数字或数字是<span class="token number">0</span>，<span class="token constant">ES</span>会把值转换为整数，

<span class="token number">NaN</span>不等于任何包括<span class="token number">NaN</span>在内的任何值

<span class="token comment">// 数值转换</span>
<span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">Number</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">//0</span>
<span class="token function">Number</span><span class="token punctuation">(</span>undifined<span class="token punctuation">)</span> <span class="token comment">//NaN</span>
Number<span class="token punctuation">.</span><span class="token punctuation">.</span>如果字符串包含有效的十六进制则转换为对应的十进制整数值
PasreInt<span class="token punctuation">.</span><span class="token punctuation">.</span>如果开头不是数字或加减号，返回<span class="token number">NaN</span>
</code></pre></div><ul><li>string字符串</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code>字符串本身是不可变的，通常情况下的修改字符串的值本质上是新建另一个字符串

<span class="token comment">//转换为字符串</span>
<span class="token keyword">let</span> age <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
age<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ‘10’</span>
age<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '12'</span>
<span class="token comment">//如果是数字的话可以转为进制</span>

<span class="token comment">//ES6新增：模板字面量---使用`我是字符串`反引号定义字符串</span>

<span class="token comment">//原始字符串 String.raw()</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">\u00A9</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ©</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span>raw<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">\u00A9</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// \u00A9</span>
</code></pre></div><ul><li>boolean布尔值</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Boolean('hhh') // true

数据类型     转换为 true 的值     转换为 false 的值
Boolean          true                 false
String        非空字符串            &quot;&quot;（空字符串）
Number      非零数值（包括无穷值） 0、NaN（参见后面的相关内容）
Object          任意对象               null
Undefined      N/A（不存在）          undefined
</code></pre></div><ul><li>symbol符号，ES6新增</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。</span>

<span class="token comment">//Symbol()函数不能和new一起使用</span>
</code></pre></div></li> <li><p>复杂数据类型</p> <ul><li>object
<ul><li>constructor</li> <li><strong>hasOwnProperty(propertyName) : 用于判断是否有给定的属性</strong></li> <li>isPrototypeOf(object): 判断当前对象是否为另一个对象的原型</li> <li>toString()</li> <li>valueOf() : 通常与toString返回值相同</li> <li>对象的属性是无序的，不能保证遍历时的顺序</li></ul></li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>typeof 是操作符。可带参数也可不带【typeof 'hhh' === typeof( 'hhh' )】</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">typeof</span> a<span class="token punctuation">;</span>    <span class="token comment">//'undefined'</span>
<span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//'boolean'</span>
<span class="token keyword">typeof</span> <span class="token string">'123'</span><span class="token punctuation">;</span>  <span class="token comment">//'string'</span>
<span class="token keyword">typeof</span> <span class="token number">123</span><span class="token punctuation">;</span>   <span class="token comment">//'number'</span>
<span class="token keyword">typeof</span> <span class="token number">NaN</span><span class="token punctuation">;</span>   <span class="token comment">//'number'</span>
<span class="token keyword">typeof</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment">//'object' </span>

<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">typeof</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//'object'</span>

<span class="token keyword">var</span>  <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">typeof</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//'function'</span>

<span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">class</span> <span class="token class-name">c</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//'function'</span>
严格来讲，函数在 ECMAScript 中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此，就有必要通过 <span class="token keyword">typeof</span> 操作符来区分函数和其他对象。
</code></pre></div></li></ul> <h4 id="操作符"><a href="#操作符" class="header-anchor">#</a> 操作符</h4> <ul><li><p>一元操作符</p> <ul><li>递增递减： ++/--</li> <li>一元加和减：+str =&gt; Number(str)：布尔值 false 和 true 转换为 0 和 1，字符串根据特殊规则进行解析，对象会调用它们的 valueOf()和/或 toString() 方法以得到可以转换的值。</li></ul></li> <li><p>位操作符</p> <ul><li>ES中数值以64位格式存储，但位操作符不直接应用到64位表示，而是先把值转换为32位整数进行位操作后再把结果转换为64位</li> <li>32位整数前31位表示数值，第32位表示符号，0为正，1为负</li> <li><strong>按位非（~）</strong>：取反，补数。<strong>按位非的最终效果是对数值取反并减 1</strong></li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> num1 <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span> <span class="token comment">// 二进制 00000000000000000000000000011001</span>
<span class="token keyword">let</span> num2 <span class="token operator">=</span> <span class="token operator">~</span>num1<span class="token punctuation">;</span> <span class="token comment">// 二进制 11111111111111111111111111100110</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// -26</span>
</code></pre></div><ul><li><strong>按位与（&amp;）</strong>：11得1，其它得0</li> <li><strong>按位或（|）</strong>：00得0，其它得1</li> <li><strong>按位异或（^）</strong>：相同取1，相反取0</li> <li><strong>左移（&lt;&lt;）</strong>: 空位补0，保留符号</li> <li><strong>有符号右移（&gt;&gt;）</strong></li> <li><strong>无符号右移（&gt;&gt;&gt;）</strong></li></ul></li> <li><p>布尔操作符</p> <ul><li>逻辑非</li> <li>逻辑与</li> <li>逻辑或</li></ul></li> <li><p>乘性操作符</p> <ul><li>乘法操作符</li> <li>除法操作符</li> <li>取模操作符 %</li></ul></li> <li><p>指数操作符（ES7新增）**</p> <ul><li>3 ** 2 = 9 与Math.pow(3，2)等效</li></ul></li> <li><p>相等操作符</p> <ul><li><p><strong>等于和不等于：==    !=</strong></p> <ul><li><p>会进行强制类型转换</p></li> <li><p>如果任一操作数是布尔值，则将其<strong>转换为数值再比较</strong>是否相等。false 转换为 0，true 转换 为 1。</p></li> <li><p>如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串<strong>转换为数值</strong>，再比较是否相等。</p></li> <li><p>如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法取得其原始值，再 根据前面的规则进行比较。 在进行比较时，这两个操作符会遵循如下规则。</p></li> <li><p><strong>null 和 undefined 相等</strong>。 null 和 undefined 不能转换为其他类型的值再进行比较。</p></li> <li><p>如果有任一操作数是 NaN，则相等操作符返回 false，不相等操作符返回 true。记住：即使两 个操作数都是 NaN，相等操作符也返回 false，因为按照规则，NaN 不等于 NaN。</p></li> <li><p><strong>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象， 则相等操作符返回 true。否则，两者不相等</strong>。</p></li> <li><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">null</span> <span class="token operator">==</span> <span class="token keyword">undefined</span>         <span class="token boolean">true</span>
<span class="token string">&quot;NaN&quot;</span> <span class="token operator">==</span> <span class="token number">NaN</span>              <span class="token boolean">false</span>
<span class="token number">5</span> <span class="token operator">==</span> <span class="token number">NaN</span>                  <span class="token boolean">false</span>
<span class="token number">NaN</span> <span class="token operator">==</span> <span class="token number">NaN</span>                <span class="token boolean">false</span>
<span class="token number">NaN</span> <span class="token operator">!=</span> <span class="token number">NaN</span>                <span class="token boolean">true</span>
<span class="token boolean">false</span> <span class="token operator">==</span> <span class="token number">0</span>                <span class="token boolean">true</span>
<span class="token boolean">true</span> <span class="token operator">==</span> <span class="token number">1</span>                 <span class="token boolean">true</span>
<span class="token boolean">true</span> <span class="token operator">==</span> <span class="token number">2</span>                 <span class="token boolean">false</span>
<span class="token keyword">undefined</span> <span class="token operator">==</span> <span class="token number">0</span>            <span class="token boolean">false</span>
<span class="token keyword">null</span> <span class="token operator">==</span> <span class="token number">0</span>                 <span class="token boolean">false</span>
<span class="token string">&quot;5&quot;</span> <span class="token operator">==</span> <span class="token number">5</span>                  <span class="token boolean">true</span>
</code></pre></div></li></ul></li> <li><p><strong>全等和不全等： ===   !==</strong></p></li></ul></li> <li><p>条件操作符</p> <ul><li>？ ：</li></ul></li></ul> <h4 id="语句"><a href="#语句" class="header-anchor">#</a> 语句</h4> <ul><li>if语句</li> <li>do-while语句</li> <li>while语句</li> <li>for语句</li> <li>for-in语句：枚举<strong>对象</strong>中的非符号键<strong>属性</strong>。如果是对象就返回key,如果是数组就返回index</li> <li>for-of：于遍历<strong>可迭代对象</strong>的<strong>元素</strong></li> <li>标签语句</li> <li>break和continue语句</li> <li>with语句</li> <li>switch语句：和其它语言不同的是，ES的switch的条件的值不需要是常量、也可以是变量或表达式</li></ul> <h4 id="函数"><a href="#函数" class="header-anchor">#</a> 函数</h4> <ul><li>不指定返回值的函数实际上会返回undefined</li></ul> <h3 id="四、变量、作用域与内存"><a href="#四、变量、作用域与内存" class="header-anchor">#</a> 四、变量、作用域与内存</h3> <h4 id="原始值与引用值"><a href="#原始值与引用值" class="header-anchor">#</a> 原始值与引用值</h4> <ul><li>引用值是保存在内存中的对象，js不允许直接访问内存位置</li> <li>原始值-栈；引用值-堆</li> <li><strong>确定类型</strong>：instanceof</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code>person <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">;</span> <span class="token comment">// 变量 person 是 Object 吗？</span>
colors <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">;</span> <span class="token comment">// 变量 colors 是 Array 吗？</span>
pattern <span class="token keyword">instanceof</span> <span class="token class-name">RegExp</span><span class="token punctuation">;</span> <span class="token comment">// 变量 pattern 是 RegExp 吗？</span>
</code></pre></div><h4 id="执行上下文与作用域javascript"><a href="#执行上下文与作用域javascript" class="header-anchor">#</a> 执行上下文与作用域javascript</h4> <ul><li><p>浏览器中，全局上下文就是常说的window对象。使用let和const的顶级声明不会定义在全局上下文中，但在作用域链解析上效果和var一样</p></li> <li><p>全局上下文在关闭浏览器或网页时才会被销毁</p></li> <li><p>let：块级作用域，一对包含花括号{ }界定。if块、while块、function块</p></li></ul> <h4 id="垃圾回收"><a href="#垃圾回收" class="header-anchor">#</a> 垃圾回收</h4> <ul><li>执行环境负责在代码执行时管理内存</li> <li>基本思路：确定哪个变量不会再 使用，然后释放它占用的内存
<ul><li>垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行</li> <li>找出哪些变量不会再使用</li> <li>在浏览器的发展史上，用到过两种主要的标记策略：标记清理和引用计数
<ul><li>标记清理：垃圾回收程序运行的时候，会标记<strong>内存中存储的</strong>所有变量，然后看哪些变量是在上下文中的变量，去掉标记，剩下的就是要清理的</li> <li>引用计数：少用。引用计数在代码中存在循环引用时会出现问题。</li></ul></li></ul></li> <li>性能：垃圾回收程序的时间调度问题</li> <li>内存管理
<ul><li>如果数据不再必要，把它设置为null，从而释放其引用</li> <li>隐藏类和删除操作</li> <li>内存泄漏：
<ul><li>新建变量没有关键字</li> <li>闭包。引用的数据无法被清理</li></ul></li> <li>静态分配和对象池</li></ul></li></ul> <h3 id="五、基本引用类型"><a href="#五、基本引用类型" class="header-anchor">#</a> 五、基本引用类型</h3> <p>引用类型是把数据和功能组织到一起的结构</p> <h4 id="date"><a href="#date" class="header-anchor">#</a> Date</h4> <ul><li>new Date() 构造函数传参为空则取当前时间，传参为毫秒格式</li> <li>Date.parse() 获取时间戳。如果new Date()传入的是时间字符串，会默认内部调用Date.parse()</li></ul> <div class="language- extra-class"><pre class="language-text"><code>支持下列日期格式：
1、 “月/日/年”，如&quot;5/23/2019&quot;；
2、 “月名 日, 年”，如&quot;May 23, 2019&quot;；
3、 “周几 月名 日 年 时:分:秒 时区”，如&quot;Tue May 23 2019 00:00:00 GMT-0700&quot;；
4、 YYYY-MM-DDTHH:mm:ss.sssZ
</code></pre></div><ul><li>Date.now() 当前时间戳</li> <li>重写了toLocaleString、toString、valueOf。
<ul><li>toLocaleString() - 2/1/2019 12:00:00 AM</li> <li>toString() - Thu Feb 1 2019 00:00:00 GMT-0800 (Pacific Standard Time)</li></ul></li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token operator">**</span><span class="token operator">**</span><span class="token operator">**</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  返回日期的毫秒表示；与 <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>相同
<span class="token operator">**</span><span class="token operator">**</span><span class="token operator">**</span><span class="token function">setTime</span><span class="token punctuation">(</span>milliseconds<span class="token punctuation">)</span> 设置日期的毫秒表示，从而修改整个日期
<span class="token operator">**</span><span class="token operator">**</span><span class="token operator">**</span><span class="token function">getFullYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 返回 <span class="token number">4</span> 位数年（即 <span class="token number">2019</span> 而不是 <span class="token number">19</span>）
<span class="token function">getUTCFullYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 返回 <span class="token constant">UTC</span> 日期的 <span class="token number">4</span> 位数年
<span class="token function">setFullYear</span><span class="token punctuation">(</span>year<span class="token punctuation">)</span> 设置日期的年（year 必须是 <span class="token number">4</span> 位数）
<span class="token function">setUTCFullYear</span><span class="token punctuation">(</span>year<span class="token punctuation">)</span> 设置 <span class="token constant">UTC</span> 日期的年（year 必须是 <span class="token number">4</span> 位数）
<span class="token operator">**</span><span class="token operator">*</span><span class="token function">getMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 返回日期的月（<span class="token number">0</span> 表示 <span class="token number">1</span> 月，<span class="token number">11</span> 表示 <span class="token number">12</span> 月）
<span class="token function">getUTCMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 返回 <span class="token constant">UTC</span> 日期的月（<span class="token number">0</span> 表示 <span class="token number">1</span> 月，<span class="token number">11</span> 表示 <span class="token number">12</span> 月）
<span class="token function">setMonth</span><span class="token punctuation">(</span>month<span class="token punctuation">)</span> 设置日期的月（month 为大于 <span class="token number">0</span> 的数值，大于 <span class="token number">11</span> 加年）
<span class="token function">setUTCMonth</span><span class="token punctuation">(</span>month<span class="token punctuation">)</span> 设置 <span class="token constant">UTC</span> 日期的月（month 为大于 <span class="token number">0</span> 的数值，大于 <span class="token number">11</span> 加年）
<span class="token operator">**</span><span class="token operator">**</span><span class="token operator">**</span><span class="token function">getDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 返回日期中的日（<span class="token number">1</span><span class="token operator">~</span><span class="token number">31</span>）
<span class="token function">getUTCDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 返回 <span class="token constant">UTC</span> 日期中的日（<span class="token number">1</span><span class="token operator">~</span><span class="token number">31</span>）
<span class="token function">setDate</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span> 设置日期中的日（如果 date 大于该月天数，则加月）
<span class="token function">setUTCDate</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span> 设置 <span class="token constant">UTC</span> 日期中的日（如果 date 大于该月天数，则加月）
<span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 返回日期中表示周几的数值（<span class="token number">0</span> 表示周日，<span class="token number">6</span> 表示周六）
<span class="token function">getUTCDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 返回 <span class="token constant">UTC</span> 日期中表示周几的数值（<span class="token number">0</span> 表示周日，<span class="token number">6</span> 表示周六）
<span class="token operator">**</span><span class="token operator">**</span><span class="token operator">**</span><span class="token function">getHours</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 返回日期中的时（<span class="token number">0</span><span class="token operator">~</span><span class="token number">23</span>）
<span class="token function">getUTCHours</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 返回 <span class="token constant">UTC</span> 日期中的时（<span class="token number">0</span><span class="token operator">~</span><span class="token number">23</span>）
<span class="token function">setHours</span><span class="token punctuation">(</span>hours<span class="token punctuation">)</span> 设置日期中的时（如果 hours 大于 <span class="token number">23</span>，则加日）
<span class="token function">setUTCHours</span><span class="token punctuation">(</span>hours<span class="token punctuation">)</span> 设置 <span class="token constant">UTC</span> 日期中的时（如果 hours 大于 <span class="token number">23</span>，则加日）
<span class="token operator">**</span><span class="token operator">**</span><span class="token operator">**</span><span class="token function">getMinutes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 返回日期中的分（<span class="token number">0</span><span class="token operator">~</span><span class="token number">59</span>）
<span class="token function">getUTCMinutes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 返回 <span class="token constant">UTC</span> 日期中的分（<span class="token number">0</span><span class="token operator">~</span><span class="token number">59</span>）
<span class="token function">setMinutes</span><span class="token punctuation">(</span>minutes<span class="token punctuation">)</span> 设置日期中的分（如果 minutes 大于 <span class="token number">59</span>，则加时）
<span class="token function">setUTCMinutes</span><span class="token punctuation">(</span>minutes<span class="token punctuation">)</span> 设置 <span class="token constant">UTC</span> 日期中的分（如果 minutes 大于 <span class="token number">59</span>，则加时）
<span class="token operator">**</span><span class="token operator">**</span><span class="token operator">**</span><span class="token function">getSeconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 返回日期中的秒（<span class="token number">0</span><span class="token operator">~</span><span class="token number">59</span>）
<span class="token function">getUTCSeconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 返回 <span class="token constant">UTC</span> 日期中的秒（<span class="token number">0</span><span class="token operator">~</span><span class="token number">59</span>）
<span class="token function">setSeconds</span><span class="token punctuation">(</span>seconds<span class="token punctuation">)</span> 设置日期中的秒（如果 seconds 大于 <span class="token number">59</span>，则加分）
<span class="token function">setUTCSeconds</span><span class="token punctuation">(</span>seconds<span class="token punctuation">)</span> 设置 <span class="token constant">UTC</span> 日期中的秒（如果 seconds 大于 <span class="token number">59</span>，则加分）
<span class="token operator">**</span><span class="token operator">**</span><span class="token operator">**</span><span class="token function">getMilliseconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 返回日期中的毫秒
<span class="token function">getUTCMilliseconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 返回 <span class="token constant">UTC</span> 日期中的毫秒
<span class="token function">setMilliseconds</span><span class="token punctuation">(</span>milliseconds<span class="token punctuation">)</span> 设置日期中的毫秒
<span class="token function">setUTCMilliseconds</span><span class="token punctuation">(</span>milliseconds<span class="token punctuation">)</span> 设置 <span class="token constant">UTC</span> 日期中的毫秒
<span class="token function">getTimezoneOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 返回以分钟计的 <span class="token constant">UTC</span> 与本地时区的偏移量（如美国 <span class="token constant">EST</span> 即“东部标准时间”返回 <span class="token number">300</span>，进入夏令时的地区可能有所差异）
</code></pre></div><h4 id="regexp"><a href="#regexp" class="header-anchor">#</a> RegExp</h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> expression <span class="token operator">=</span> <span class="token operator">/</span>pattern<span class="token operator">/</span>flags<span class="token punctuation">;</span>
表示匹配模式的标记。
 g：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。
 i：不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写。
 m：多行模式，表示查找到一行文本末尾时会继续查找。
 y：粘附模式，表示只查找从 lastIndex 开始及之后的字符串。
 u：Unicode 模式，启用 Unicode 匹配。
 s：dotAll 模式，表示元字符<span class="token punctuation">.</span>匹配任何字符（包括\n 或\r）。
</code></pre></div><ul><li>exec( ): 返回匹配项的数组或null</li></ul> <h4 id="原始值包装类型"><a href="#原始值包装类型" class="header-anchor">#</a> 原始值包装类型</h4> <ul><li><p>Boolean、Number、String</p> <ul><li>String
<ul><li>substring()</li> <li>charAt()</li> <li>charCodeAt()</li> <li>indexOf()  没找到则返回-1</li> <li>laseIndexOf()</li> <li>startsWith()</li> <li>endsWith()</li> <li>includes(targetStr, ? index)</li> <li>trim()</li> <li>reqeat()</li> <li>toLocaleUpperCase()、.toUpperCase()</li> <li>toLocaleLowerCase()、toLowerCase()</li> <li>match()方法 == RegExp.exec()</li></ul></li> <li>Number
<ul><li>toFixed(2) 保留两位小数</li></ul></li></ul></li> <li><div class="language- extra-class"><pre class="language-text"><code>注意，使用 new 调用原始值包装类型的构造函数，与调用同名的转型函数并不一样。例如：
let value = &quot;25&quot;;
let number = Number(value); // 转型函数
console.log(typeof number); // &quot;number&quot;
let obj = new Number(value); // 构造函数
console.log(typeof obj); // &quot;object&quot; 
</code></pre></div></li></ul> <h4 id="单例内置对象"><a href="#单例内置对象" class="header-anchor">#</a> 单例内置对象</h4> <ul><li><p>Global对象: 事实上，不存在全局变量或全局函 数这种东西。在全局作用域中定义的变量和函数都会变成 Global 对象的属性</p> <ul><li>isNaN()</li> <li>isFinite()</li> <li>parseInt()</li> <li>parseFloat()</li> <li>encodeURI()</li> <li>eval()   这个方法就是一个完 整的 ECMAScript 解释器</li> <li>对象属性：Global 对象有很多属性，其中一些前面已经提到过了。像 undefined、NaN 和 Infinity 等特殊 值都是 Global 对象的属性。此外，所有原生引用类型构造函数，比如 Object 和 Function，也都是 Global 对象的属性。</li> <li>window对象：Global对象的代理</li></ul></li> <li><h4 id="math"><a href="#math" class="header-anchor">#</a> math</h4> <div class="language- extra-class"><pre class="language-text"><code>Math 对象上提供的计算要比直接在 JavaScript 实现的快得多，因为 Math 对象上的计算使用了 JavaScript 引擎中更高效的实现和处理器指令。但使用 Math 计算的问题是精度会因浏览器、操作系统、指令集和硬件而异。
</code></pre></div><ul><li>Math.max()和Math.min()</li> <li>舍入方法
<ul><li>Math.ceil( ) 向上取整</li> <li>Math.floor( ) 向下取整</li> <li>Math.round( ) 四舍五入</li> <li>Math.fround( ) 返回数值最接近的单精度（32位）浮点数表示</li></ul></li> <li>Math.random( ) 随机数[0，1）</li> <li>其它：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Math.abs(x)           返回 x 的绝对值
Math.exp(x)           返回 Math.E 的 x 次幂
Math.expm1(x)         等于 Math.exp(x) - 1
Math.log(x)           返回 x 的自然对数
Math.log1p(x)         等于 1 + Math.log(x)
Math.pow(x, power)    返回 x 的 power 次幂
Math.hypot(...nums)   返回 nums 中每个数平方和的平方根
Math.clz32(x)         返回 32 位整数 x 的前置零的数量
Math.sign(x)          返回表示 x 符号的 1、0、-0 或-1
Math.trunc(x)         返回 x 的整数部分，删除所有小数
Math.sqrt(x)          返回 x 的平方根
Math.cbrt(x)          返回 x 的立方根
Math.acos(x)          返回 x 的反余弦
Math.acosh(x)         返回 x 的反双曲余弦
Math.asin(x)          返回 x 的反正弦
Math.asinh(x)         返回 x 的反双曲正弦
Math.atan(x)          返回 x 的反正切
Math.atanh(x)         返回 x 的反双曲正切
Math.atan2(y, x)      返回 y/x 的反正切
Math.cos(x)           返回 x 的余弦
Math.sin(x)           返回 x 的正弦
Math.tan(x)           返回 x 的正切
</code></pre></div></li></ul> <h3 id="六、集合引用类型"><a href="#六、集合引用类型" class="header-anchor">#</a> 六、集合引用类型</h3> <h4 id="object"><a href="#object" class="header-anchor">#</a> Object</h4> <h4 id="array"><a href="#array" class="header-anchor">#</a> Array</h4> <ul><li><p>Array.from( ) :将类数组结构转换为数组示例</p> <ul><li>将字符串拆分为单字符数组</li> <li>将集合（Map）和映射（Set）转换为一个数组</li> <li>对现有数组进行浅复制</li> <li>arguments对象转数组</li></ul></li> <li><p>Array.of( ) :将一组参数转换为数组实例</p></li> <li><p>判断数组类型：</p> <ul><li>arr <strong>instanceof</strong> Array 在只有一个网页的时候适用（只有一个全局上下文</li> <li><strong>Array.isArray( )</strong></li></ul></li> <li><p>迭代器方法</p> <ul><li>keys()</li> <li>values()</li> <li>aEntries()</li></ul></li> <li><p>转换方法</p> <ul><li>toString()</li> <li>valueOf()</li> <li>join()</li></ul></li> <li><p>栈方法</p> <ul><li>push()</li> <li>pop()</li></ul></li> <li><p>队列方法</p> <ul><li>unshift()</li> <li>shift()</li></ul></li> <li><p>排序方法</p> <ul><li>reverse()</li> <li>sort(?fun())  fun()返回正值则第一个参数在第二个参数后</li></ul></li> <li><p>操作方法</p> <ul><li><p>concat() : arr1.concat(arr2) 返回新数组；</p> <div class="language- extra-class"><pre class="language-text"><code>
</code></pre></div></li> <li><p>slice(startIndex, ?endIndex): 返回索引内元素，不影响原数组</p></li> <li><p>splice(要删除的第一个元素Index, 删除的元素数量，?要插入的元素...),影响原数组</p></li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">]</span>
<span class="token keyword">const</span> result <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'bbb'</span><span class="token punctuation">)</span> <span class="token comment">// result []</span>
<span class="token comment">// arr ['a', 'bbb', 'b', 'c']</span>
</code></pre></div></li> <li><p>搜索和位置方法</p> <ul><li>indexOf() 没有返回-1</li> <li>lastIndexOf()  没有返回-1</li> <li>includes() 返回布尔值</li> <li>find() 返回第一个匹配的元素</li> <li>findIndex()</li></ul></li> <li><p>迭代方法, 都不改变原数组</p> <ul><li>every() 返回布尔值</li> <li>filter()</li> <li>forEach()</li> <li>map()</li> <li>some() 返回布尔值</li></ul></li> <li><p>归并方法</p> <ul><li>reduce()</li> <li>reduceRight()</li></ul></li></ul> <h4 id="定型数组"><a href="#定型数组" class="header-anchor">#</a> 定型数组</h4> <p>定型数组（typed array）是 ECMAScript 新增的结构，目的是提升向原生库传输数据的效率。实际上，
JavaScript 并没有“TypedArray”类型，它所指的其实是一种特殊的包含数值类型的数组。</p> <ul><li>ArrayBuffer是一个普通的 JavaScript 构造函数，可用于在内存中分配特定数量的字节空间。</li> <li>DataView
<ul><li>ElementType</li> <li>字节序</li> <li>边界情形</li> <li>定型数组，是另一种形式的 ArrayBuffer 视图。</li></ul></li></ul> <h4 id="map"><a href="#map" class="header-anchor">#</a> Map</h4> <p>ES6新增。真正的键/值存储机制</p> <ul><li><p>基本API</p> <ul><li>创建 new Map()</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/**如果想在创建的同时初始化实例，可以给 Map 构造函数传入一个可迭代对象，需要包含键/值对数
组。可迭代对象中的每个键/值对都会按照迭代顺序插入到新映射实例中：**/</span>
<span class="token comment">// 使用嵌套数组初始化映射</span>
<span class="token keyword">const</span> m1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
 <span class="token punctuation">[</span><span class="token string">&quot;key1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;val1&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
 <span class="token punctuation">[</span><span class="token string">&quot;key2&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;val2&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
 <span class="token punctuation">[</span><span class="token string">&quot;key3&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;val3&quot;</span><span class="token punctuation">]</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> pair <span class="token keyword">of</span> m<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token function">alert</span><span class="token punctuation">(</span>pair<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// [key1,val1]</span>
<span class="token comment">// [key2,val2]</span>
<span class="token comment">// [key3,val3]</span>
</code></pre></div><ul><li>size() 大小</li> <li>get(key)</li> <li>set(key, val) 新增键值对</li> <li>delete(key)</li> <li>clear()</li> <li>has(key)</li> <li>entries() 转数组</li> <li>forEach((val, key) =&gt; {})</li> <li>与object不同，Map实例会维护键值对的插入顺序--迭代顺序保证</li></ul></li></ul> <h4 id="weakmap"><a href="#weakmap" class="header-anchor">#</a> WeakMap</h4> <p>ES6新增</p> <ul><li>弱映射的键只能是object或其继承类型</li> <li>只要建存在，键/值对就会存在于映射中，并被当作对值的引用，因此就不会被当作垃圾回收。</li> <li>不可迭代建</li> <li>一些用途
<ul><li>私有变量</li></ul></li></ul> <h4 id="set"><a href="#set" class="header-anchor">#</a> Set</h4> <p>ES6新增</p> <ul><li>基本API
<ul><li>创建 new Set()</li> <li>add()</li> <li>has()</li> <li>size() 大小</li> <li>delete</li></ul></li></ul> <h4 id="weakset"><a href="#weakset" class="header-anchor">#</a> WeakSet</h4> <h4 id="迭代与扩展操作"><a href="#迭代与扩展操作" class="header-anchor">#</a> 迭代与扩展操作</h4> <h3 id="七、迭代器与生成器"><a href="#七、迭代器与生成器" class="header-anchor">#</a> 七、迭代器与生成器</h3> <h4 id="迭代器模式"><a href="#迭代器模式" class="header-anchor">#</a> 迭代器模式</h4> <ul><li><p>迭代器协议</p> <ul><li>next()</li> <li>done属性和value属性</li></ul></li> <li><p>提前终止迭代器</p></li> <li><p>for-of循环通过 break、continue、return 或 throw 提前退出；</p></li></ul> <h4 id="生成器"><a href="#生成器" class="header-anchor">#</a> 生成器</h4> <ul><li>生成器基础：生成器的形式是一个函数，函数名称前面加一个星号（*）表示它是一个生成器。只要是可以定义
函数的地方，就可以定义生成器。</li> <li>next()</li> <li>yeild</li> <li>return</li> <li>throw</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 生成器函数声明</span>
<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">generatorFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// 生成器函数表达式</span>
<span class="token keyword">let</span> <span class="token function-variable function">generatorFn</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><h3 id="八、对象、类与面向对象编程"><a href="#八、对象、类与面向对象编程" class="header-anchor">#</a> 八、对象、类与面向对象编程</h3> <p>无序集合</p> <h4 id="理解对象"><a href="#理解对象" class="header-anchor">#</a> 理解对象</h4> <ul><li><p>属性的类型</p> <ul><li><p>数据属性</p> <ul><li><p>[[Configurable]]：表示属性是否可以通过 delete 删除并重新定义</p></li> <li><p>[[Enumerable]]：表示属性是否可以通过 for-in 循环返回</p></li> <li><p>[[Writable]]：表示属性的值是否可以被修改</p></li> <li><p>[[Value]]：包含属性实际的值</p></li> <li><p>要修改对象的默认特性，就必须使用Object.defineProperty</p></li> <li><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">&quot;name&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
 <span class="token literal-property property">writable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
 <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token string">&quot;Nicholas&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;Nicholas&quot;</span>
person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Greg&quot;</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;Nicholas&quot; </span>
</code></pre></div></li></ul></li> <li><p>访问器属性</p> <ul><li><p>[[get]]：获取函数，在读取属性时调用。默认值为 undefined。</p></li> <li><p>[[set]]：设置函数，在写入属性时调用。默认值为 undefined。</p></li> <li><p>[[Configurable]]：表示属性是否可以通过 delete 删除并重新定义</p></li> <li><p>[[Enumerable]]：表示属性是否可以通过 for-in 循环返回</p></li> <li><p>访问器属性是不能直接定义的，必须使用 Object.defineProperty()。</p></li> <li><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 定义一个对象，包含伪私有成员 year_和公共成员 edition</span>
<span class="token keyword">let</span> book <span class="token operator">=</span> <span class="token punctuation">{</span>
 <span class="token literal-property property">year_</span><span class="token operator">:</span> <span class="token number">2017</span><span class="token punctuation">,</span>
 <span class="token literal-property property">edition</span><span class="token operator">:</span> <span class="token number">1</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>book<span class="token punctuation">,</span> <span class="token string">&quot;year&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
 <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>year_<span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token function">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">&gt;</span> <span class="token number">2017</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 	<span class="token keyword">this</span><span class="token punctuation">.</span>year_ <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
 	<span class="token keyword">this</span><span class="token punctuation">.</span>edition <span class="token operator">+=</span> newValue <span class="token operator">-</span> <span class="token number">2017</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
book<span class="token punctuation">.</span>year <span class="token operator">=</span> <span class="token number">2018</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>book<span class="token punctuation">.</span>edition<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2 </span>
</code></pre></div></li> <li><p>合并对象</p> <p>Object.assign(targetObj, obj1, ?obj2...): 实际上是对每个源对象执行浅复制（如果对象内部还有引用值，慎用），如果多个源对象有相同的属性则使用最后一个复制的值</p></li> <li><p>Object.is( ),ES6新增，与===很像，但考虑了边界情形</p></li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token string">&quot;2&quot;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>

<span class="token comment">// 正确的 0、-0、+0 相等/不等判定</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
<span class="token comment">// 这些情况在不同 JavaScript 引擎中表现不同，但仍被认为相等</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">0</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">0</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token comment">// 正确的 NaN 相等判定</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">,</span> <span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token comment">// 要确定 NaN 的相等性，必须使用极为讨厌的 isNaN()</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">NaN</span> <span class="token operator">===</span> <span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div></li> <li><p>对象解构，es6新增：使用与对象匹配的结构来实现对象属性赋值  let { name: personName, age: personAge } = person;</p></li></ul></li></ul> <h4 id="创建对象"><a href="#创建对象" class="header-anchor">#</a> 创建对象</h4> <ul><li><p>ES6 的类都仅仅是封装了 ES5.1 构造函数加原型继承的语法糖而已</p></li> <li><p>工厂模式</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 o<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
 o<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">return</span> o<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> person1 <span class="token operator">=</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>构造函数模式</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
 <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
 <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Nicholas</span>
</code></pre></div><p>缺点：其定义的方法会在每个实例上都创建一遍，没必要</p></li> <li><p>原型模式</p> <p>每个函数都会创建一个 prototype 属性，这个属性是一个对象，包含应该由特定引用类型的实例 共享的属性和方法。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;Nicholas&quot;</span>
</code></pre></div><ul><li>原型
<ul><li>prototype属性</li> <li>constructor属性：Person.prototype.constructor 指向 Person</li> <li>在自定义构造函数时，原型对象默认只会获得 constructor 属性，其他的所有方法都继承自 Object。</li> <li>每次调用构造函数创建一个新实例，这个实例的内部[[Prototype]]指针就会被赋值为构造函数的原型对象。</li> <li>脚本中没有访问这个[[Prototype]]特性的标准方式，但 Firefox、Safari 和 Chrome 会在每个对象上暴露__proto__属性，通过这个属性可以访问对象的原型。</li> <li>isPrototypeOf(): Person.prototype.isPrototypeOf(person2); // true</li></ul></li> <li>原型层级
<ul><li>hasOwnProperty( ) 于确定某个属性是在<strong>实例</strong>上还是在原型对象上</li></ul></li> <li>原型和in操作符
<ul><li>单独使用时，只要可以在原型链上找到对应的字符，就返回true</li></ul></li> <li>属性枚举顺序
<ul><li>for-in 循环、Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()以及 Object.assign()在属性枚举顺序方面有很大区别</li> <li>for-in 循环和 Object.keys() 的枚举顺序是不确定的，取决于 JavaScript 引擎，可能因浏览器而异。</li> <li>Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()和 Object.assign() 的枚举顺序是确定性的。</li></ul></li> <li>对象迭代
<ul><li>Object.values( ) 返回对象值数组</li> <li>Object.entries( ) 返回键值对数组</li></ul></li></ul></li> <li><p>继承</p> <ul><li>实现继承是 ECMAScript 唯一支持的继承方式，而这主要是通过原型链实现的。</li> <li>instanceof、 isPrototypeOf( )</li> <li>盗用构造函数，解决原型包含引用值导致的继承问题</li> <li>组合继承
<ul><li>使用原型链继承原型上的属性和方法</li> <li>通过盗用函数继承实例属性</li></ul></li></ul></li> <li><p>类</p> <ul><li>类声明不能被提升</li> <li>类受块作用域限制</li> <li>typeof 类 === 'function'</li> <li>ES6原生支持了类继承机制，背后使用的依旧是原型链</li> <li>构造函数、HomeObject、super( )</li></ul></li></ul> <h3 id="九、代理和反射"><a href="#九、代理和反射" class="header-anchor">#</a> 九、代理和反射</h3> <p>给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对 目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制</p> <h4 id="代理基础"><a href="#代理基础" class="header-anchor">#</a> 代理基础</h4> <ul><li>代理是目标对象的抽象</li> <li>类似C++指针</li> <li>Proxy构造函数创建（目标对象，处理程序对象）</li> <li>使用代理的主要目的是可以定义<strong>捕获器（trap）</strong>,每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 定义get捕获器
const target = {
 foo: 'bar'
};
const handler = {
 // 捕获器在处理程序对象中以方法名为键
 get() {
 return 'handler override';
 }
};
const proxy = new Proxy(target, handler);
</code></pre></div><ul><li><p>捕获器参数和反射API</p> <ul><li><p>全局Reflect对象的同名方法</p></li> <li><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token punctuation">{</span>
 <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token string">'bar'</span><span class="token punctuation">,</span>
 <span class="token literal-property property">baz</span><span class="token operator">:</span> <span class="token string">'qux'</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
 <span class="token function">get</span><span class="token punctuation">(</span>trapTarget<span class="token punctuation">,</span> property<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">let</span> decoration <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>property <span class="token operator">===</span> <span class="token string">'foo'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 decoration <span class="token operator">=</span> <span class="token string">'!!!'</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span> <span class="token operator">+</span> decoration<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// bar!!!</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// bar</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>baz<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// qux</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>baz<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// qux </span>
</code></pre></div></li> <li><p>捕获器不变式</p></li> <li><p>可撤销代理</p></li> <li><p>实用反射API</p></li></ul></li></ul> <h4 id="代理捕获器与反射方法"><a href="#代理捕获器与反射方法" class="header-anchor">#</a> 代理捕获器与反射方法</h4> <ul><li>代理可以捕获13种不同的基本操作，这些操作有各自不同的反射API方法、参数、关联ES操作和不变式</li> <li>任何一种操作，只会有一个捕获处理程序被调用</li> <li>get() -- Reflect.get()</li> <li>set() -- Reflect.set()</li> <li>has() -- Reflect.has()</li> <li>defineProperty()</li> <li>getOwnPropertyDescriptor</li> <li>deleteProperty()</li> <li>ownKeys( )</li> <li>getPrototypeOf()</li> <li>setPrototypeOf()</li> <li>isExtensible()</li> <li>preventExtensions()</li> <li>apply()</li> <li>construct()</li></ul> <h4 id="代理模式"><a href="#代理模式" class="header-anchor">#</a> 代理模式</h4> <ul><li>跟踪属性访问</li> <li>隐藏属性</li> <li>属性验证</li> <li>函数与构造函数参数验证</li> <li>数据绑定与可观察对象</li></ul> <h3 id="十、函数"><a href="#十、函数" class="header-anchor">#</a> 十、函数</h3> <h4 id="箭头函数"><a href="#箭头函数" class="header-anchor">#</a> 箭头函数</h4> <ul><li><p>不能使用arguments、super和new.target,</p></li> <li><p>也不能用作构造函数，</p></li> <li><p>没有prototype属性</p></li></ul> <h4 id="函数名"><a href="#函数名" class="header-anchor">#</a> 函数名</h4> <ul><li><p>函数名就是指向函数的指针</p></li> <li><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> <span class="token function-variable function">bar</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token function-variable function">baz</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// foo</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// bar</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>baz<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// baz</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//（空字符串）</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// anonymous </span>
</code></pre></div></li></ul> <h4 id="理解函数"><a href="#理解函数" class="header-anchor">#</a> 理解函数</h4> <p>参数在内部表现为一个数组</p> <p>没有重载</p> <h4 id="默认参数值"><a href="#默认参数值" class="header-anchor">#</a> 默认参数值</h4> <p>​	function func(aaa = 'defaultValue')</p> <p>​    暂时性死区</p> <h4 id="参数扩展与收集"><a href="#参数扩展与收集" class="header-anchor">#</a> 参数扩展与收集</h4> <p>扩展操作符传参</p> <h4 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="header-anchor">#</a> 函数声明与函数表达式</h4> <p>函数声明提升</p> <p>函数表达式方式不会被提升</p> <h4 id="函数内部"><a href="#函数内部" class="header-anchor">#</a> 函数内部</h4> <ul><li>arguments。类数组对象</li> <li>this
<ul><li>标准函数中，this引用的是<strong>把函数当成方法调用的上下文对象</strong>-----&gt;必须要到函数被调用时才能确定</li> <li>箭头函数中，this引用的是<strong>定义箭头函数的上下文</strong></li></ul></li> <li>new.target ,ES6新增
<ul><li>如果函数是正常调用的，new.target = undefined</li> <li>如果是new关键字，则new.target将引用被调用的构造函数</li></ul></li> <li>caller: 引用的是调用当前函数的函数，如果是全局作用域中则为null</li></ul> <h4 id="函数属性与方法"><a href="#函数属性与方法" class="header-anchor">#</a> 函数属性与方法</h4> <ul><li>length</li> <li>prototype
<ul><li>是保存引用类型所有实例方法的地方,这意味着toString()、valueOf()等方法实际上都保存在 prototype 上</li></ul></li> <li>apply(函数内this的值，参数数组)</li> <li>call(函数内this的值，参数，参数...)</li> <li>bind(被绑定的对象)</li></ul> <h4 id="函数表达式"><a href="#函数表达式" class="header-anchor">#</a> 函数表达式</h4> <ul><li>函数表达式创建的也叫匿名函数</li></ul> <h4 id="递归"><a href="#递归" class="header-anchor">#</a> 递归</h4> <ul><li><p>arguments.callee ：一个指向正在执行的函数的指针</p></li> <li><p>尾调用优化</p></li></ul> <h4 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h4> <ul><li>指的是引用了另一个函数作用域中变量的函数</li> <li>this和arguments都是不能在内部函数中访问的</li> <li>内存泄漏</li></ul> <h4 id="立即调用的函数表达式"><a href="#立即调用的函数表达式" class="header-anchor">#</a> 立即调用的函数表达式</h4> <p>（function() { //块级作用域 }）()</p> <h4 id="私有变量"><a href="#私有变量" class="header-anchor">#</a> 私有变量</h4> <h3 id="十一、期约与异步函数"><a href="#十一、期约与异步函数" class="header-anchor">#</a> 十一、期约与异步函数</h3> <h4 id="异步编程"><a href="#异步编程" class="header-anchor">#</a> 异步编程</h4> <h4 id="期约"><a href="#期约" class="header-anchor">#</a> 期约</h4> <ul><li><p>Promise/A+规范</p></li> <li><p>Promise</p> <ul><li>状态机：pending、fulfilled、rejected</li> <li>resolve, reject</li> <li>then catch finally</li> <li>Promise.all() 、Promise.race()</li></ul></li></ul> <h4 id="异步函数"><a href="#异步函数" class="header-anchor">#</a> 异步函数</h4> <ul><li>async/await</li></ul> <h3 id="十二、bom"><a href="#十二、bom" class="header-anchor">#</a> 十二、BOM</h3> <p>是使用Js开发web应用程序的核心。BOM 提供了与网页无关的浏览器功能对象。</p> <h4 id="window对象"><a href="#window对象" class="header-anchor">#</a> window对象</h4> <p>ES中的Global对象、浏览器窗口的javascript接口</p> <ul><li><p>Global作用域</p></li> <li><p>窗口关系：top 对象始终指向最上层（最外层）窗口，即浏览器窗口本身。而 parent 对象则始终指向当前窗 口的父窗口。如果当前窗口是最上层窗口，则 parent 等于 top（都等于 window）。最上层的 window 如果不是通过 window.open()打开的，那么其 name 属性就不会包含值</p></li> <li><p>窗口位置和像素比</p> <ul><li>screenLeft、screenTop</li> <li>moveTo( )、moveBy( )</li></ul></li> <li><p>窗口大小</p> <ul><li>innerWidth( )、innerHeight( )浏览器窗口大小/(移动端)视口大小</li> <li>outerWidth( )、outerHeight()浏览器本身大小</li> <li>document.documentElement.clientWidth 和 document.documentElement.clientHeight 返回页面视口的宽度和高度</li></ul></li> <li><p>视口位置</p> <ul><li>度量文档相对于视口滚动距离的属性有两对，返回相等的值：window.pageXoffset/window. scrollX 和 window.pageYoffset/window.scrollY。</li> <li>可以使用 scroll()、scrollTo()和 scrollBy()方法滚动页面。</li></ul></li> <li><p>导航与打开新窗口</p> <ul><li>window.open()
<ul><li>弹出窗口</li> <li>。。。</li></ul></li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 与&lt;a href=&quot;http://www.wrox.com&quot; target=&quot;topFrame&quot;/&gt;相同</span>
window<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&quot;http://www.wrox.com/&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;topFrame&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>定时器</p></li> <li><p>系统对话框</p> <ul><li>alert()</li> <li>confirm()</li></ul> <div class="language- extra-class"><pre class="language-text"><code>if (confirm(&quot;Are you sure?&quot;)) {
 alert(&quot;I'm so glad you're sure!&quot;);
} else {
 alert(&quot;I'm sorry to hear you're not sure.&quot;);
} 
</code></pre></div><ul><li>promt()</li></ul></li></ul> <h4 id="location对象"><a href="#location对象" class="header-anchor">#</a> location对象</h4> <ul><li>这个对象独特的地方在于，它既是 window 的属性，也是 document 的属性</li> <li>提供了当前窗口中加载文档的信息，以及通常的导航功能</li></ul> <h4 id="navigator对象"><a href="#navigator对象" class="header-anchor">#</a> navigator对象</h4> <div class="language- extra-class"><pre class="language-text"><code>activeVrDisplays 返回数组，包含 ispresenting 属性为 true 的 VRDisplay 实例
appCodeName 即使在非 Mozilla 浏览器中也会返回&quot;Mozilla&quot;
appName 浏览器全名
appVersion 浏览器版本。通常与实际的浏览器版本不一致
battery 返回暴露 Battery Status API 的 BatteryManager 对象
buildId 浏览器的构建编号
connection 返回暴露 Network Information API 的 NetworkInformation 对象
cookieEnabled 返回布尔值，表示是否启用了 cookie
credentials 返回暴露 Credentials Management API 的 CredentialsContainer 对象
deviceMemory 返回单位为 GB 的设备内存容量
doNotTrack 返回用户的“不跟踪”（do-not-track）设置
geolocation 返回暴露 Geolocation API 的 Geolocation 对象
getVRDisplays() 返回数组，包含可用的每个 VRDisplay 实例
getUserMedia() 返回与可用媒体设备硬件关联的流
hardwareConcurrency 返回设备的处理器核心数量
javaEnabled 返回布尔值，表示浏览器是否启用了 Java
language 返回浏览器的主语言
languages 返回浏览器偏好的语言数组
locks 返回暴露 Web Locks API 的 LockManager 对象
mediaCapabilities 返回暴露 Media Capabilities API 的 MediaCapabilities 对象
mediaDevices 返回可用的媒体设备
maxTouchPoints 返回设备触摸屏支持的最大触点数
mimeTypes 返回浏览器中注册的 MIME 类型数组
onLine 返回布尔值，表示浏览器是否联网
oscpu 返回浏览器运行设备的操作系统和（或）CPU
permissions 返回暴露 Permissions API 的 Permissions 对象
platform 返回浏览器运行的系统平台
plugins 返回浏览器安装的插件数组。在 IE 中，这个数组包含页面中所有&lt;embed&gt;元素
product 返回产品名称（通常是&quot;Gecko&quot;）
productSub 返回产品的额外信息（通常是 Gecko 的版本）
registerProtocolHandler() 将一个网站注册为特定协议的处理程序
requestMediaKeySystemAccess() 返回一个期约，解决为 MediaKeySystemAccess 对象
sendBeacon() 异步传输一些小数据
serviceWorker 返回用来与 ServiceWorker 实例交互的 ServiceWorkerContainer
share() 返回当前平台的原生共享机制
storage 返回暴露 Storage API 的 StorageManager 对象
userAgent 返回浏览器的用户代理字符串
vendor 返回浏览器的厂商名称
vendorSub 返回浏览器厂商的更多信息
vibrate() 触发设备振动
webdriver 返回浏览器当前是否被自动化程序控制
</code></pre></div><ul><li>检测插件-plugins数组</li></ul> <h4 id="screen对象"><a href="#screen对象" class="header-anchor">#</a> screen对象</h4> <div class="language- extra-class"><pre class="language-text"><code>availHeight 屏幕像素高度减去系统组件高度（只读）
availLeft 没有被系统组件占用的屏幕的最左侧像素（只读）
availTop 没有被系统组件占用的屏幕的最顶端像素（只读）
availWidth 屏幕像素宽度减去系统组件宽度（只读）
colorDepth 表示屏幕颜色的位数；多数系统是 32（只读）
height 屏幕像素高度
left 当前屏幕左边的像素距离
pixelDepth 屏幕的位深（只读）
top 当前屏幕顶端的像素距离
width 屏幕像素宽度
orientation 返回 Screen Orientation API 中屏幕的朝向
</code></pre></div><h4 id="history对象"><a href="#history对象" class="header-anchor">#</a> history对象</h4> <p>出于安全考虑，这个对象不会暴露用户访问过的 URL， 但可以通过它在不知道实际 URL 的情况下前进和后退。</p> <ul><li>导航</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 后退一页
history.go(-1);
// 前进一页
history.go(1);
// 前进两页
history.go(2);
// 后退一页
history.back();
// 前进一页
history.forward();
</code></pre></div><ul><li>历史状态管理</li></ul> <h3 id="十三、客户端检测"><a href="#十三、客户端检测" class="header-anchor">#</a> 十三、客户端检测</h3> <h4 id="能力检测"><a href="#能力检测" class="header-anchor">#</a> 能力检测</h4> <p>只需关心自己需要的能力存在与否</p> <h4 id="用户代理检测"><a href="#用户代理检测" class="header-anchor">#</a> 用户代理检测</h4> <p>检测通过浏览器的用户代理字符串确定使用的是什么浏览器；不可靠。</p> <h4 id="软件与硬件检测"><a href="#软件与硬件检测" class="header-anchor">#</a> 软件与硬件检测</h4> <p>现代浏览器提供了一组与页面执行环境相关的信息，包括浏览器、操作系统、硬件和周边设备信息。 这些属性可以通过暴露在 window.navigator 上的一组 API 获得。</p> <h3 id="十四、dom"><a href="#十四、dom" class="header-anchor">#</a> 十四、DOM</h3> <p>文档对象模型，是HTML和XML文档的编程接口</p> <p>与浏览器中的HTML网页有关，并在Js中提供了DOM API</p> <h4 id="节点层级"><a href="#节点层级" class="header-anchor">#</a> 节点层级</h4> <p>document节点表示每个文档的根节点</p> <p>&lt;html&gt;-----在 HTML 页面中，文档元素始终是&lt;html&gt;元素。</p> <ul><li><p>Node类型</p> <ul><li><p>所有节点类型都继承 Node 类型</p></li> <li><p>nodeName 与 nodeValue 保存着有关节点的信息。对元素 而言，nodeName 始终等于元素的标签名，而 nodeValue 则始终为 null。</p></li> <li><p>节点关系</p> <ul><li>每个节点都有一个 <strong>childNodes</strong> 属性，其中包含一个 NodeList 的实例</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> firstChild <span class="token operator">=</span> someNode<span class="token punctuation">.</span>childNodes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> secondChild <span class="token operator">=</span> someNode<span class="token punctuation">.</span>childNodes<span class="token punctuation">.</span><span class="token function">item</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> count <span class="token operator">=</span> someNode<span class="token punctuation">.</span>childNodes<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
</code></pre></div><ul><li>每个节点都有一个 <strong>parentNode</strong> 属性，指向其 DOM 树中的父元素</li> <li><strong>firstChild</strong> <strong>lastChild</strong></li> <li><strong>hasChildNodes</strong>() 查询是否有子节点</li></ul></li> <li><p>操纵节点</p> <ul><li><strong>appendChild()</strong> 用于在childNodes列表末尾添加节点，返回新添加的节点。<em>如果把文档中已经存在的节点传给 appendChild()，则这个节点会从之前的位置被转移到新位置。</em></li> <li><strong>insertBefore(要插入的节点，参照节点)</strong></li> <li><strong>replaceChild(要插入的节点，要替换的节点)</strong></li> <li><strong>removeChild(要移除的节点)</strong></li> <li><strong>cloneNode(要复制的节点，是否深克隆)</strong></li> <li>normallize()</li></ul></li></ul></li> <li><p>document类型</p> <ul><li><p>在浏览器中，文档对象 document 是 HTMLDocument 的实例（HTMLDocument 继承 Document），表示整个 HTML 页面。<strong>document 是 window 对象的属性</strong>，因此是一个全局对象。</p></li> <li><p>文档子节点</p> <ul><li>DocumentType、Element、Processing-Indtruction、Comment</li> <li>documentElement: 始终指向&lt;html&gt;元素</li> <li>body: 直接指向&lt;body&gt;元素</li> <li>DocumentType</li></ul></li> <li><p>文档信息</p> <ul><li>title</li> <li>URL</li> <li>domain 取得域名。可利用实现frame通信</li> <li>referrer 取得来源</li></ul></li> <li><p>定位元素</p> <ul><li>getElementById(),如果id相同，返回第一个</li> <li>getElementsByTagName，返回NodeList</li> <li>getElementsByName，返回NodeList</li></ul></li> <li><p>特殊集合</p> <ul><li>document.anchors 包含文档中所有带 name 属性的元素。</li> <li>document.applets 包含文档中所有元素（因为元素已经不建议使用，所 以这个集合已经废弃）。</li> <li>document.forms 包含文档中所有元素（与 document.getElementsByTagName (&quot;form&quot;) 返回的结果相同）。</li> <li>document.images 包含文档中所有&lt;img&gt;元素（与 document.getElementsByTagName (&quot;img&quot;) 返回的结果相同）。</li> <li>document.links 包含文档中所有带 href 属性的元素。</li></ul></li> <li><p>DOM兼容性检测</p></li> <li><p>文档写入</p> <ul><li>write(str)</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&quot;&lt;strong&gt;&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;&lt;/strong&gt;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>writeIn(str)还会在字符串末尾追加一个换行符 （\n）</li> <li>open()</li> <li>close()</li></ul></li></ul></li> <li><p>Element类型：Element 表示XML或HTML 元素，对外暴露出访问元素标签名、子节点和属性的能力</p> <ul><li>HTML元素</li> <li>取得属性\设置属性
<ul><li>getAttribute(&quot;id&quot;)</li> <li>setAttribute(&quot;class&quot;,&quot;mycassName&quot;)</li> <li>removeAttribute()</li></ul></li> <li>创建元素
<ul><li><strong>document.createElement(&quot;tagName&quot;)</strong></li></ul></li> <li>元素后代</li></ul></li> <li><p>Text类型</p> <ul><li>&lt;li&gt;间的空格</li></ul></li> <li><p>Comment类型</p> <ul><li>注释</li></ul></li> <li><p>CDATASection类型</p></li> <li><p>DocumentType类型</p></li> <li><p>DocumentFragment 类型</p></li> <li><p>Attr 类型。属性节点尽管是节点，却不被认为是 DOM 文档树的一部分。</p></li></ul> <h4 id="dom编程"><a href="#dom编程" class="header-anchor">#</a> DOM编程</h4> <ul><li><p>动态脚本&lt;script&gt;</p></li> <li><p>动态样式</p> <ul><li>&lt;link&gt;元素用于包含CSS外部文件，而&lt;style&gt;元素用于添加嵌入样式</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> link <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;link&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
link<span class="token punctuation">.</span>rel <span class="token operator">=</span> <span class="token string">&quot;stylesheet&quot;</span><span class="token punctuation">;</span>
link<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">&quot;text/css&quot;</span><span class="token punctuation">;</span>
link<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token string">&quot;styles.css&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> head <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">&quot;head&quot;</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
head<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span><span class="token punctuation">;</span> 

<span class="token keyword">let</span> style <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;style&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
style<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">&quot;text/css&quot;</span><span class="token punctuation">;</span>
style<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token string">&quot;body{background-color:red}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> head <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">&quot;head&quot;</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
head<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>style<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre></div></li> <li><p>操作表格</p></li></ul> <h4 id="mutationobserver接口"><a href="#mutationobserver接口" class="header-anchor">#</a> MutationObserver接口</h4> <ul><li><p>可以在DOM被修改时异步执行回调</p> <ul><li>observe(DOM 节点， MutationObserverInit 对象)，，，<strong>观察者</strong></li></ul> <div class="language- extra-class"><pre class="language-text"><code>let observer = new MutationObserver(() =&gt; console.log('&lt;body&gt; attributes changed'));
observer.observe(document.body, { attributes: true });
//观察属性： attributes: true
//观察字符数据   characterData: true
//观察子节点 childList: true
//观察子树  subtree: true

document.body.className = 'foo';
console.log('Changed body class');
// Changed body class
// &lt;body&gt; attributes changed
注意，回调中的 console.log()是后执行的。这表明回调并非与实际的 DOM 变化同步执行
</code></pre></div></li> <li><p>MutationRecord</p></li> <li><p>disconnect() 终止执行回调</p></li> <li><p>复用MutationObserver</p></li> <li><p>重用MutationObserver，被disconnect之后</p></li> <li><p>MutationObserverInit与观察范围</p></li> <li><p>异步回调与记录队列</p> <ul><li>每次变化的信息保存在MutationRecord实例中，然后添加到记录队列</li> <li>每个队列对每个MutationObserver实例是唯一的</li></ul></li> <li><p>性能、内存与垃圾回收</p> <ul><li>将变化回调委托给微任务来执行可以保证事件同步触发，同时避免随之而来的混乱</li> <li>MutationObserver 实例与目标节点之间的引用关系是非对称的。MutationObserver 拥有对要 观察的目标节点的弱引用。然而，目标节点却拥有对 MutationObserver 的强引用。</li></ul></li> <li><p>MutationObserver 是为代替性能不好的 MutationEvent 而问世的。使用它可以有效精准地监控 DOM 变化，而且 API 也相对简单。</p></li></ul> <h3 id="十五、dom扩展"><a href="#十五、dom扩展" class="header-anchor">#</a> 十五、DOM扩展</h3> <h4 id="selectors-api"><a href="#selectors-api" class="header-anchor">#</a> Selectors API</h4> <p>是 W3C 推荐标准，规定了浏览器原生支 持的 CSS 查询 API</p> <ul><li><p>querySelector()</p> <ul><li><p>接收 CSS 选择符参数，返回匹配该模式的第一个后代元素，如果没有匹配 项则返回 null。</p></li> <li><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 取得&lt;body&gt;元素</span>
<span class="token keyword">let</span> body <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;body&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 取得 ID 为&quot;myDiv&quot;的元素</span>
<span class="token keyword">let</span> myDiv <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;#myDiv&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 取得类名为&quot;selected&quot;的第一个元素</span>
<span class="token keyword">let</span> selected <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;.selected&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li> <li><p>querySelectorAll()</p></li> <li><p>matches()</p></li> <li><p>find()</p></li> <li><p>findAll()</p></li></ul> <h4 id="元素遍历"><a href="#元素遍历" class="header-anchor">#</a> 元素遍历</h4> <h4 id="html5"><a href="#html5" class="header-anchor">#</a> HTML5</h4> <p>在所有以前的 HTML 规范中，从未出现过描述 JavaScript 接口的情形，但HTML5 规范包含了与标记相关的大量 JavaScript API 定义</p> <ul><li>CSS类扩展
<ul><li>getElementsByClassName()</li> <li>classList
<ul><li>add(value)，向类名列表中添加指定的字符串值 value。如果这个值已经存在，则什么也不做。</li> <li>contains(value)，返回布尔值，表示给定的 value 是否存在。</li> <li>remove(value)，从类名列表中删除指定的字符串值 value。</li> <li>toggle(value)，如果类名列表中已经存在指定的 value，则删除；如果不存在，则添加。</li></ul></li></ul></li> <li>焦点管理
<ul><li>document.activeElement</li> <li>document.hasFocus</li></ul></li> <li>HTMLDocument扩展
<ul><li>readyState
<ul><li>loading 文档正在加载</li> <li>complete 加载完成</li></ul></li> <li>compatMode属性
<ul><li>指示浏览器当前处于什么渲染模式（标准、混杂）</li></ul></li> <li>head属性</li></ul></li> <li>字符集属性
<ul><li>characterSet 属性表示文档实际使用的 字符集，也可以用来指定新字符集。这个属性的默认值是&quot;UTF-16&quot;，但可以通过元素或响应头， 以及新增的 characterSeet 属性来修改</li> <li>document.characterSet = &quot;UTF-8&quot;;</li></ul></li> <li>自定义数据属性
<ul><li>data-     开头，设置</li> <li>通过dataset访问</li></ul></li> <li>插入标记
<ul><li>innerHTML</li> <li>outerHTML 包含自身元素</li> <li>insertAdjacentHTML(要插入的位置，HTML/文本)，insertAdjacentText()
<ul><li>&quot;beforebegin&quot;，插入当前元素前面，作为前一个同胞节点；</li> <li>&quot;afterbegin&quot;，插入当前元素内部，作为新的子节点或放在第一个子节点前面；</li> <li>&quot;beforeend&quot;，插入当前元素内部，作为新的子节点或放在最后一个子节点后面；</li> <li>&quot;afterend&quot;，插入当前元素后面，作为下一个同胞节点。</li></ul></li></ul></li> <li>内存和性能问题
<ul><li>可能在浏览器（特别是 IE）中导致内存问题</li> <li>比如，如果被移除的 子树元素中之前有关联的事件处理程序或其他 JavaScript 对象（作为元素的属性），那它们之间的绑定关 系会滞留在内存中。如果这种替换操作频繁发生，页面的内存占用就会持续攀升。</li> <li>在使用 innerHTML、 outerHTML 和 insertAdjacentHTML()之前，最好手动删除要被替换的元素上关联的事件处理程序和 JavaScript 对象。</li></ul></li> <li>跨站点脚本</li> <li>scrollIntoView()  存在于所有 HTML 元素上
<ul><li>alignToTop 是一个布尔值。
<ul><li>true：窗口滚动后元素的顶部与视口顶部对齐。</li> <li>false：窗口滚动后元素的底部与视口底部对齐。</li></ul></li> <li>scrollIntoViewOptions 是一个选项对象。
<ul><li>behavior：定义过渡动画，可取的值为&quot;smooth&quot;和&quot;auto&quot;，默认为&quot;auto&quot;。</li> <li>block：定义垂直方向的对齐，可取的值为&quot;start&quot;、&quot;center&quot;、&quot;end&quot;和&quot;nearest&quot;，默认为 &quot;start&quot;。</li> <li>inline：定义水平方向的对齐，可取的值为&quot;start&quot;、&quot;center&quot;、&quot;end&quot;和&quot;nearest&quot;，默认为 &quot;nearest&quot;。</li></ul></li> <li>不传参数等同于 alignToTop 为 true。</li></ul></li></ul> <h4 id="专有扩展"><a href="#专有扩展" class="header-anchor">#</a> 专有扩展</h4> <ul><li>children属性</li> <li>contains方法</li> <li>插入标记
<ul><li>innerText</li> <li>outerText</li></ul></li> <li>滚动
<ul><li>scrollIntoViewIfNeeded()</li></ul></li></ul> <h3 id="十六、dom2和dom3"><a href="#十六、dom2和dom3" class="header-anchor">#</a> 十六、DOM2和DOM3</h3> <p>在DOM结构上加入更多交互能力</p> <ul><li>DOM Core：在 DOM1 核心部分的基础上，为节点增加方法和属性。</li> <li>DOM Views：定义基于样式信息的不同视图。</li> <li>DOM Events：定义通过事件实现 DOM 文档交互。</li> <li>DOM Style：定义以编程方式访问和修改 CSS 样式的接口。</li> <li>DOM Traversal and Range：新增遍历 DOM 文档及选择文档内容的接口。</li> <li>DOM HTML：在 DOM1 HTML 部分的基础上，增加属性、方法和新接口。</li> <li>DOM Mutation Observers：定义基于 DOM 变化触发回调的接口。这个模块是 DOM4 级模块， 用于取代 Mutation Events。</li></ul> <h4 id="dom的演进"><a href="#dom的演进" class="header-anchor">#</a> DOM的演进</h4> <h4 id="样式"><a href="#样式" class="header-anchor">#</a> 样式</h4> <ul><li>元素尺寸
<ul><li><strong>偏移尺寸</strong>：包含元素在屏幕上占用的所有视觉空间。元素在页 面上的视觉空间由其高度和宽度决定，包括所有内边距、滚动条和边框（但<strong>不包含外边距</strong>）。
<ul><li>offsetHeight</li> <li>offsetLeft, 元素左边框外侧距离包含元素左边框内侧的像素数,相对于包含元素</li> <li>offsetTop</li> <li>offsetWidth</li></ul></li> <li><strong>客户端尺寸</strong>：包含元素内容及其内边距所占用的空间，<strong>不包含边框和外边距</strong>, 不包含滚动条
<ul><li>clientHeight</li> <li>clientWidth</li> <li>常用于确定 浏览器视口尺寸</li></ul></li> <li><strong>滚动尺寸</strong> <ul><li>scrollHeight 元素内容的总高度</li> <li>scrollLeft 左侧隐藏的像素数</li> <li>scrollTop 顶部隐藏的像素数</li> <li>scrollWidth  元素内容的总宽度</li></ul></li> <li>确定元素尺寸getBoundingClientRect()</li></ul></li></ul> <h4 id="遍历"><a href="#遍历" class="header-anchor">#</a> 遍历</h4> <h4 id="范围"><a href="#范围" class="header-anchor">#</a> 范围</h4> <h3 id="十七、事件"><a href="#十七、事件" class="header-anchor">#</a> 十七、事件</h3> <h4 id="事件流"><a href="#事件流" class="header-anchor">#</a> 事件流</h4> <ul><li>事件冒泡（IE）：从最具体元素开始向上传播</li> <li>事件捕获：从顶层到具体</li> <li>DOM事件流
<ul><li>事件捕获</li> <li>到达目标</li> <li>事件冒泡</li></ul></li></ul> <h4 id="事件处理程序"><a href="#事件处理程序" class="header-anchor">#</a> 事件处理程序</h4> <ul><li>HTML事件处理程序
<ul><li>onclick</li></ul></li> <li>DOM0事件处理程序</li> <li>DOM2事件处理程序
<ul><li>为事件处理程序的赋值和移除定义了两个方法：addEventListener()和 removeEventListener()</li> <li>它们接收 3 个参数：事件名、事件处理函 数和一个布尔值，true 表示在捕获阶段调用事件处理程序，false（默认值）表示在冒泡阶段调用事 件处理程序。</li></ul></li> <li>IE事件处理程序
<ul><li>在冒泡阶段添加事件处理</li></ul></li> <li>跨浏览器事件处理程序</li></ul> <h4 id="事件对象"><a href="#事件对象" class="header-anchor">#</a> 事件对象</h4> <ul><li>DOM事件对象</li> <li>IE事件对象</li></ul> <h4 id="事件类型"><a href="#事件类型" class="header-anchor">#</a> 事件类型</h4> <ul><li>用户界面事件（UIEvent）：涉及与 BOM 交互的通用浏览器事件。
<ul><li>load事件：会在整个页面（包括 所有外部资源如图片、JavaScript 文件和 CSS 文件）加载完成后触发。
<ul><li>监听</li> <li>元素添加onload属性</li></ul></li> <li>unload事件</li> <li>resize事件</li> <li>scroll事件</li></ul></li> <li>焦点事件（FocusEvent）：在元素获得和失去焦点时触发。
<ul><li> blur：当元素<strong>失去焦点</strong>时触发。这个事件不冒泡，所有浏览器都支持。</li> <li>DOMFocusIn：当元素获得焦点时触发。这个事件是 focus 的冒泡版。Opera 是唯一支持这个事 件的主流浏览器。DOM3 Events 废弃了 DOMFocusIn，推荐 focusin。</li> <li>DOMFocusOut：当元素失去焦点时触发。这个事件是 blur 的通用版。Opera 是唯一支持这个事 件的主流浏览器。DOM3 Events 废弃了 DOMFocusOut，推荐 focusout。</li> <li>focus：当元素<strong>获得焦点</strong>时触发。这个事件不冒泡，所有浏览器都支持。</li> <li>focusin：当元素获得焦点时触发。这个事件是 focus 的冒泡版。</li> <li>focusout：当元素失去焦点时触发。这个事件是 blur 的通用版。</li></ul></li> <li>鼠标事件（MouseEvent）：使用鼠标在页面上执行某些操作时触发。
<ul><li>click</li> <li>dblclick</li> <li>mousedown</li> <li>mouseenter</li> <li>mouselease</li> <li>mousemove</li> <li>mouseout</li> <li>mouseover</li> <li>mouseup</li></ul></li> <li>滚轮事件（WheelEvent）：使用鼠标滚轮（或类似设备）时触发。</li> <li>输入事件（InputEvent）：向文档中输入文本时触发。</li> <li>键盘事件（KeyboardEvent）：使用键盘在页面上执行某些操作时触发。
<ul><li>keypress</li></ul></li> <li>合成事件（CompositionEvent）：在使用某种 IME（Input Method Editor，输入法编辑器）输入 字符时触发。</li></ul> <h4 id="内存和性能"><a href="#内存和性能" class="header-anchor">#</a> 内存和性能</h4> <ul><li>事件委托
<ul><li>将事件冒泡委托至上级元素</li></ul></li> <li>删除事件处理程序</li></ul> <h4 id="模拟事件"><a href="#模拟事件" class="header-anchor">#</a> 模拟事件</h4> <h3 id="十八、动画与canvas图形"><a href="#十八、动画与canvas图形" class="header-anchor">#</a> 十八、动画与Canvas图形</h3> <h4 id="使用requestanimationframe"><a href="#使用requestanimationframe" class="header-anchor">#</a> 使用requestAnimationFrame</h4> <ul><li>早期定时动画通过setInterval控制</li> <li>时间间隔的问题</li> <li>requestAnimationFrame()只会调用一次传入的函数，所以每次更新用户界面时需要再手 动调用它一次</li> <li>cancelAnimationFrame</li></ul> <h4 id="基本的画布功能"><a href="#基本的画布功能" class="header-anchor">#</a> 基本的画布功能</h4> <ul><li>创建元素时至少要设置其 width 和 height 属性</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token operator">&lt;</span>canvas id<span class="token operator">=</span><span class="token string">&quot;drawing&quot;</span> width<span class="token operator">=</span><span class="token string">&quot;200&quot;</span> height<span class="token operator">=</span><span class="token string">&quot;200&quot;</span><span class="token operator">&gt;</span><span class="token constant">A</span> drawing <span class="token keyword">of</span> something<span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>canvas<span class="token operator">&gt;</span>
</code></pre></div><ul><li>getContext() : 以获取对绘图上下文的 引用</li> <li>toDataURL() : 导出元素上的图像</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> drawing <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;drawing&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 确保浏览器支持&lt;canvas&gt;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>drawing<span class="token punctuation">.</span>getContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">// 取得图像的数据 URI</span>
 <span class="token keyword">let</span> imgURI <span class="token operator">=</span> drawing<span class="token punctuation">.</span><span class="token function">toDataURL</span><span class="token punctuation">(</span><span class="token string">&quot;image/png&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">// 显示图片</span>
 <span class="token keyword">let</span> image <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;img&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 image<span class="token punctuation">.</span>src <span class="token operator">=</span> imgURI<span class="token punctuation">;</span>
 document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>image<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</code></pre></div><h4 id="_2d绘图上下文"><a href="#_2d绘图上下文" class="header-anchor">#</a> 2D绘图上下文</h4> <ul><li><p>填充和描边fillStyle 和 strokeStyle</p> <ul><li>填充以指定样式（颜色、渐变或图像）自动填充形 状</li> <li>描边只为图形边界着色</li></ul></li> <li><p>绘制矩形</p> <ul><li>fillRect(x ，y， 矩形宽度，矩形高度)  实心</li> <li>strokeRect(x ，y， 矩形宽度，矩形高度)  空心</li> <li>clearRect(x ，y， 矩形宽度，矩形高度)  擦除矩形</li></ul></li> <li><p>绘制路径</p> <ul><li>beginPath()
<ul><li>arc(x, y, radius半径, startAngle起始角度, endAngle结束角度, counterclockwise是否逆时针)</li> <li>arcTo(x1, y1, x2, y2, radius)</li> <li>bezierCurveTo(c1x, c1y, c2x, c2y, x, y)</li> <li>lineTo(x,y)</li> <li>moveTo(x,y)</li> <li>quadraticCurveTo(cx, cy, x, y)</li> <li>rect(x, y, width, height)</li></ul></li></ul></li> <li><p>绘制文本</p> <ul><li><p>fillText()</p></li> <li><p>strokeText</p> <ul><li><p>font</p></li> <li><p>textAlign</p></li> <li><p>textBaseLine</p></li> <li><div class="language-javascript extra-class"><pre class="language-javascript"><code>context<span class="token punctuation">.</span>font <span class="token operator">=</span> <span class="token string">&quot;bold 14px Arial&quot;</span><span class="token punctuation">;</span>
context<span class="token punctuation">.</span>textAlign <span class="token operator">=</span> <span class="token string">&quot;center&quot;</span><span class="token punctuation">;</span>
context<span class="token punctuation">.</span>textBaseline <span class="token operator">=</span> <span class="token string">&quot;middle&quot;</span><span class="token punctuation">;</span>
context<span class="token punctuation">.</span><span class="token function">fillText</span><span class="token punctuation">(</span><span class="token string">&quot;12&quot;</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li></ul></li> <li><p>变换</p> <ul><li><p>rotate(angle)：围绕原点把图像旋转 angle 弧度</p></li> <li><p>scale(scaleX, scaleY)：通过在 x 轴乘以 scaleX、在 y 轴乘以 scaleY 来缩放图像。scaleX 和 scaleY 的默认值都是 1.0</p></li> <li><p>translate(x, y)：把原点移动到(x, y)。执行这个操作后，坐标(0, 0)就会变成(x, y)</p></li> <li><p>transform(m1_1, m1_2, m2_1, m2_2, dx, dy)：像下面这样通过矩阵乘法直接修改矩阵</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>m1_1 m1_2 dx
m2_1 m2_2 dy
<span class="token number">0</span>    <span class="token number">0</span>    <span class="token number">1</span>
</code></pre></div></li> <li><p>setTransform(m1_1, m1_2, m2_1, m2_2, dx, dy)：把矩阵重置为默认值，再以传入的 参数调用 transform()</p></li></ul></li> <li><p>绘制图像</p> <ul><li>drawImage(image/canvas, x, y, width, height, 目标区域 x 坐标、目标区域 y 坐标、 目标区域宽度和目标区域高度)</li> <li><strong>如果绘制的图像来自其他域而非当前页面，则不能获取 其数据</strong></li></ul></li> <li><p>阴影</p> <ul><li>shadowColor：CSS 颜色值，表示要绘制的阴影颜色，默认为黑色。</li> <li>shadowOffsetX：阴影相对于形状或路径的 x 坐标的偏移量，默认为 0。</li> <li>shadowOffsetY：阴影相对于形状或路径的 y 坐标的偏移量，默认为 0。</li> <li>shadowBlur：像素，表示阴影的模糊量。默认值为 0，表示不模糊。</li></ul></li> <li><p>渐变</p> <ul><li>渐变通过 CanvasGradient 的实例表示</li> <li>要创建一个新的 线性渐变，可以调用上下文的 createLinearGradient()方法：起点 x 坐标、 起点 y 坐标、终点 x 坐标和终点 y 坐标</li> <li>使用 addColorStop()方法为渐变指定色标</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> gradient <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">createLinearGradient</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
gradient<span class="token punctuation">.</span><span class="token function">addColorStop</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&quot;white&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
gradient<span class="token punctuation">.</span><span class="token function">addColorStop</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&quot;black&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>图案</p> <ul><li>用 createPattern(image/video/canvas, 该如何重复图像)
<ul><li>repeat</li> <li>repeat-x</li> <li>repeat-y</li> <li>no-repeat</li></ul></li></ul></li> <li><p>图像数据</p> <ul><li>getImageData()方法获取原始图像数据
<ul><li>4 个参数：</li> <li>要取得数据中第一个像素的左上角坐标</li> <li>要取得的像素宽度及高度</li></ul></li></ul></li> <li><p>合成</p> <ul><li>globalAlpha 绘制内容的透明度</li> <li>globalCompositionOperation 新绘制的形状如何与上下文中已有的形状融合</li></ul></li></ul> <h4 id="webgl"><a href="#webgl" class="header-anchor">#</a> WebGL</h4> <p>3D上下文</p> <h3 id="十九、表单脚本"><a href="#十九、表单脚本" class="header-anchor">#</a> 十九、表单脚本</h3> <h4 id="表单基础"><a href="#表单基础" class="header-anchor">#</a> 表单基础</h4> <ul><li><p>提交表单</p> <ul><li><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 通用提交按钮 <span class="token operator">--</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;submit&quot;</span> value<span class="token operator">=</span><span class="token string">&quot;Submit Form&quot;</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 自定义提交按钮 <span class="token operator">--</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>button type<span class="token operator">=</span><span class="token string">&quot;submit&quot;</span><span class="token operator">&gt;</span>Submit Form<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 图片按钮 <span class="token operator">--</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;image&quot;</span> src<span class="token operator">=</span><span class="token string">&quot;graphic.gif&quot;</span><span class="token operator">&gt;</span>
    
如果表单中有上述任何一个按钮，且焦点在表单中某个控件上，则按回车键也可以提交表单。
（textarea 控件是个例外，当焦点在它上面时，按回车键会换行。）
</code></pre></div></li> <li><p>form.submit()</p></li></ul></li> <li><p>重置表单</p> <ul><li>type=&quot;reset&quot;</li> <li>form.reset()</li></ul></li></ul> <h4 id="文本框编程"><a href="#文本框编程" class="header-anchor">#</a> 文本框编程</h4> <ul><li><p>input</p></li> <li><p>textarea</p></li> <li><p>选择文本 select( )</p></li> <li><p>输入过滤</p> <ul><li><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 只允许输入数字</span>
textbox<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;keypress&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
 <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\d</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">fromCharCode</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>charCode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
 	event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li> <li><p>自动切换</p></li></ul> <h4 id="选择框编程"><a href="#选择框编程" class="header-anchor">#</a> 选择框编程</h4> <ul><li>select</li> <li>option</li></ul> <h4 id="表单序列化"><a href="#表单序列化" class="header-anchor">#</a> 表单序列化</h4> <h4 id="富文本编辑"><a href="#富文本编辑" class="header-anchor">#</a> 富文本编辑</h4> <h3 id="二十、javascript-api"><a href="#二十、javascript-api" class="header-anchor">#</a> 二十、JavaScript API</h3> <h4 id="atomics与sharedarraybuffer"><a href="#atomics与sharedarraybuffer" class="header-anchor">#</a> Atomics与SharedArrayBuffer</h4> <p>多个上下文访问 SharedArrayBuffer 时，如果同时对缓冲区执行操作，就可能出现资源争用问 题。Atomics API 通过强制同一时刻只能对缓冲区执行一个操作，可以让多个上下文安全地读写一个 SharedArrayBuffer。Atomics API 是 ES2017 中定义的。</p> <ul><li>SharedArrayBuffer
<ul><li>可以被任意多个执行上下文同时使用,意味着并发线程操作成为了可能</li></ul></li> <li>原子操作基础</li></ul> <h4 id="跨上下文消息"><a href="#跨上下文消息" class="header-anchor">#</a> 跨上下文消息</h4> <p>跨文档消息，有时候也简称为 XDM（cross-document messaging），是一种在不同执行上下文（如不 同工作线程或不同源的页面）间传递信息的能力</p> <ul><li>postMessage(消息，表示目标接收源的字符串，可选的可传输对象的数组)</li></ul> <h4 id="encoding-api"><a href="#encoding-api" class="header-anchor">#</a> Encoding API</h4> <ul><li>文本编码
<ul><li>批量编码</li> <li>流编码</li></ul></li> <li>文本解码</li></ul> <h4 id="file-api与blob-api"><a href="#file-api与blob-api" class="header-anchor">#</a> File API与Blob API</h4> <ul><li><p>FIle类型</p></li> <li><p>FileReader类型</p> <ul><li>异步文件读取机制</li> <li>readAsText(file, encoding)：从文件中读取纯文本内容并保存在 result 属性中。第二个 参数表示编码，是可选的</li> <li>readAsDataURL(file)：读取文件并将内容的数据 URI 保存在 result 属性中</li> <li>readAsBinaryString(file)：读取文件并将每个字符的二进制数据保存在 result 属性中</li> <li>readAsArrayBuffer(file)：读取文件并将文件内容以 ArrayBuffer 形式保存在 result 属性</li></ul></li> <li><p>FileReaderSync，FileReader 的同步版本</p></li> <li><p>Blob 与部分读取</p> <ul><li>Blob 实际上是 File 的超类</li> <li>blob 表示二进制大对象（binary larget object），是 JavaScript 对不可修改二进制数据的封装类型</li> <li>可以使用 FileReader 从 Blob 中读取数据</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> filesList <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;files-list&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
filesList<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;change&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
 <span class="token keyword">let</span> info <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span>
 output <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;output&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 progress <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;progress&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 files <span class="token operator">=</span> event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>files<span class="token punctuation">,</span>
 reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 blob <span class="token operator">=</span> <span class="token function">blobSlice</span><span class="token punctuation">(</span>files<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>blob<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 reader<span class="token punctuation">.</span><span class="token function">readAsText</span><span class="token punctuation">(</span>blob<span class="token punctuation">)</span><span class="token punctuation">;</span>
 reader<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 output<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">&quot;Could not read file, error code is &quot;</span> <span class="token operator">+</span>
 reader<span class="token punctuation">.</span>error<span class="token punctuation">.</span>code<span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
 reader<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 output<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> reader<span class="token punctuation">.</span>result<span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Your browser doesn't support slice().&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre></div></li> <li><p>对象URL与Blob</p></li> <li><p>读取拖放文件</p></li></ul> <h4 id="媒体元素"><a href="#媒体元素" class="header-anchor">#</a> 媒体元素</h4> <ul><li>video</li> <li>audio</li></ul> <h4 id="原生拖放"><a href="#原生拖放" class="header-anchor">#</a> 原生拖放</h4> <ul><li>dragstart</li> <li>drag</li> <li>dragend</li></ul> <h4 id="notifications-api"><a href="#notifications-api" class="header-anchor">#</a> Notifications API</h4> <p>用于向用户显示通知</p> <h4 id="page-visibility-api"><a href="#page-visibility-api" class="header-anchor">#</a> Page Visibility API</h4> <p>为 开发者提供页面对用户是否可见的信息</p> <h4 id="streams-api"><a href="#streams-api" class="header-anchor">#</a> Streams API</h4> <p>实现 Observable 接口的 JavaScript 库共享了很多流的基础概念</p> <ul><li>可读流</li> <li>可写流</li> <li>转换流</li></ul> <h4 id="计时api"><a href="#计时api" class="header-anchor">#</a> 计时API</h4> <p>Performance 接口通过 JavaScript API 暴露了浏览器内部 的度量指标，允许开发者直接访问这些信息并基于这些信息实现自己想要的功能</p> <h4 id="web组件"><a href="#web组件" class="header-anchor">#</a> Web组件</h4> <h4 id="web-cryptography-api"><a href="#web-cryptography-api" class="header-anchor">#</a> Web Cryptography API</h4> <p>描述了一套密码学工具，规范了 JavaScript 如何以安全和符合惯例的方式实现 加密</p> <h3 id="二十一、错误处理与调试"><a href="#二十一、错误处理与调试" class="header-anchor">#</a> 二十一、错误处理与调试</h3> <h4 id="浏览器错误报告"><a href="#浏览器错误报告" class="header-anchor">#</a> 浏览器错误报告</h4> <ul><li>控制台</li> <li>错误处理
<ul><li>try/catch
<ul><li>throw</li> <li>finally</li></ul></li></ul></li> <li>调试技术
<ul><li>消息记录到控制台</li> <li>debugger</li></ul></li></ul> <h4 id="错误处理"><a href="#错误处理" class="header-anchor">#</a> 错误处理</h4> <ul><li>window.onerror 事件处理程序</li></ul> <h4 id="调试技术"><a href="#调试技术" class="header-anchor">#</a> 调试技术</h4> <h4 id="旧版ie的常见错误"><a href="#旧版ie的常见错误" class="header-anchor">#</a> 旧版IE的常见错误</h4> <h3 id="二十二、处理xml"><a href="#二十二、处理xml" class="header-anchor">#</a> 二十二、处理XML</h3> <h3 id="二十三、json"><a href="#二十三、json" class="header-anchor">#</a> 二十三、JSON</h3> <ul><li>语法
<ul><li>简单值：字符串、数值、布尔值、null, 不支持undifined</li> <li>对象</li> <li>数组</li></ul></li> <li>解析和序列化
<ul><li>JSON.parse()</li> <li>JSON.stringify()  会输出不包含空格或缩进的 JSON 字符串
<ul><li>可接收第二个参数，需要序列化的属性的数组，<strong>可以通过这个特性进行对对象的部分复制</strong></li> <li>可接受第三个参数，控制缩进和空格</li></ul></li></ul></li></ul> <h3 id="二十四、网络请求与远程资源"><a href="#二十四、网络请求与远程资源" class="header-anchor">#</a> 二十四、网络请求与远程资源</h3> <h4 id="xmlhttprequest对象"><a href="#xmlhttprequest对象" class="header-anchor">#</a> XMLHttpRequest对象</h4> <ul><li><p>使用XHR</p> <ul><li><p>xhr.open(&quot;get&quot;, &quot;example.php&quot;, false);</p></li> <li><p>xhr.send(null);    请求是同步的</p></li> <li><div class="language- extra-class"><pre class="language-text"><code>let xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
 if (xhr.readyState == 4) {
 if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) {
 alert(xhr.responseText);
 } else {
 alert(&quot;Request was unsuccessful: &quot; + xhr.status);
 }
 }
};
xhr.open(&quot;get&quot;, &quot;example.php&quot;, true);
xhr.setRequestHeader(&quot;MyHeader&quot;, &quot;MyValue&quot;);
xhr.send(null); 
</code></pre></div></li></ul></li> <li><p>HTTP头部</p> <ul><li>Accept：浏览器可以处理的内容类型。</li> <li>Accept-Charset：浏览器可以显示的字符集。</li> <li>Accept-Encoding：浏览器可以处理的压缩编码类型。</li> <li>Accept-Language：浏览器使用的语言。</li> <li>Connection：浏览器与服务器的连接类型。</li> <li>Cookie：页面中设置的 Cookie。</li> <li>Host：发送请求的页面所在的域。</li> <li>Referer：发送请求的页面的 URI。注意，这个字段在 HTTP 规范中就拼错了，所以考虑到兼容 性也必须将错就错。（正确的拼写应该是 Referrer。）</li> <li>User-Agent：浏览器的用户代理字符串。</li> <li>如果需要发送额外 的请求头部，可以使用 setRequestHeader()方法</li></ul></li> <li><p>XMLHttpRequest Level 2</p> <ul><li>FormData</li> <li>超时</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code>xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&quot;get&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;timeout.php&quot;</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span>timeout <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span> <span class="token comment">// 设置 1 秒超时</span>
xhr<span class="token punctuation">.</span><span class="token function-variable function">ontimeout</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;Request did not return in a second.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre></div><ul><li>overrideMimeType()方法用于重写 XHR 响应的 MIME 类型</li></ul></li></ul> <h4 id="进度事件"><a href="#进度事件" class="header-anchor">#</a> 进度事件</h4> <p>Progress Events 是 W3C 的工作草案，定义了客户端服务器端通信</p> <ul><li><p>loadstart 在接收到响应的第一个字节时触发</p></li> <li><p>progress 在接收响应期间反复触发</p> <ul><li>接收event对象，target属性为XHR实例, 同时包含三个属性：</li> <li>lengthComputable 进度信息是否可用</li> <li>position 接收到的字节数</li> <li>totalSize 响应的 ContentLength 头部定义的总字节数</li> <li>一般用于提供进度条</li></ul></li> <li><p>error 在请求出错时触发</p></li> <li><p>abort 在调用 abort()终止连接时触发</p></li> <li><p>load 在成功接收完响应时触发</p> <ul><li><p>目的，替代readystatechange事件</p></li> <li><p>接收event对象，target属性为XHR实例</p></li> <li><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">&gt;=</span> <span class="token number">200</span> <span class="token operator">&amp;&amp;</span> xhr<span class="token punctuation">.</span>status <span class="token operator">&lt;</span> <span class="token number">300</span><span class="token punctuation">)</span> <span class="token operator">||</span> xhr<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">304</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token function">alert</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
 <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;Request was unsuccessful: &quot;</span> <span class="token operator">+</span> xhr<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&quot;get&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;altevents.php&quot;</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>只要是从服务器收到响应，无论状态码是什么，都会触发 load 事件</p></li></ul></li> <li><p>loadend 在通信完成时，且在 error、abort 或 load 之后触发</p></li></ul> <h4 id="跨源资源共享"><a href="#跨源资源共享" class="header-anchor">#</a> 跨源资源共享</h4> <ul><li>跨源资源共享（CORS，Cross-Origin Resource Sharing）
<ul><li>定义了浏览器与服务器如何实现跨源通信</li> <li>基本思路就是使用自定义的 HTTP 头部允许浏览器和服务器相互了解，以确实请求或响应 应该成功还是失败</li> <li>出于安全考虑，跨域 XHR 对象也施加了一些额外限制
<ul><li>不能使用 setRequestHeader()设置自定义头部</li> <li>不能发送和接收 cookie</li> <li>getAllResponseHeaders()方法始终返回空字符串</li></ul></li> <li>预检请求
<ul><li>服务器验证机制，允许使用自定义头部以及不同请求体内容类型
<ul><li>options方法</li> <li>预检请求返回后，结果会按响应指定的时间缓存一段时间。换句话说，只有第一次发送这种类型的 请求时才会多发送一次额外的 HTTP 请求</li></ul></li></ul></li> <li>凭据请求
<ul><li>withCredentials属性设置为 true 来表明请求会发送凭据</li> <li>响应Access-Control-Allow-Credentials: true则表明可以正常请求</li></ul></li></ul></li></ul> <h4 id="替代性跨源技术"><a href="#替代性跨源技术" class="header-anchor">#</a> 替代性跨源技术</h4> <ul><li><p>图片检测</p> <ul><li>是利用&lt;img&gt;标签实现跨域通信</li> <li>数据通过查询字符串发送，响应可以随意设置，不过一般是位图图片或值为 204 的状态码。 浏览器通过图片探测拿不到任何数据，但可以通过监听 onload 和 onerror 事件知道什么时候能接收到响应。</li> <li>图片探测的缺点是只能发 送 GET 请求和无法获取服务器响应的内容</li></ul></li> <li><p>JSONP</p> <ul><li><p>JSON with padding</p></li> <li><p>JSONP 看起来 跟 JSON 一样，只是会被包在一个函数调用里，比如： callback({ &quot;name&quot;: &quot;Nicholas&quot; });</p></li> <li><p>JSONP 调用是通过动态创建&lt;script&gt;元素并为 src 属性指定跨域 URL 实现的</p></li> <li><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//因为 JSONP 是有效的 JavaScript，所以 JSONP</span>
响应在被加载完成之后会立即执行
<span class="token keyword">function</span> <span class="token function">handleResponse</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
 You're at IP address </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>response<span class="token punctuation">.</span>ip<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, which is in
 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>response<span class="token punctuation">.</span>city<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>response<span class="token punctuation">.</span>region_name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;script&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">&quot;http://freegeoip.net/json/?callback=handleResponse&quot;</span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>script<span class="token punctuation">,</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>firstChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>JSONP 是从不同的域拉取可执行代码。如果这个域并不可信，则可能在响应中加入恶意内容。</p></li> <li><p>第二个缺点是不好确定 JSONP 请求是否失败</p></li></ul></li></ul> <h4 id="fetch-api"><a href="#fetch-api" class="header-anchor">#</a> Fetch API</h4> <p>Fetch API 能够执行 XMLHttpRequest 对象的所有任务，但更容易使用，接口也更现代化，能够在 Web 工作线程等现代 Web 工具中使用。</p> <p>XMLHttpRequest 可以选择异步，而 Fetch API 则必须是异步</p> <ul><li><p>基本用法</p> <ul><li>分派请求fetch()</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let r = fetch('/bar');
console.log(r); // Promise &lt;pending&gt;

r.then(...)
</code></pre></div><ul><li><p>读取响应</p> <ul><li><p>返回的是promise, 用then就好啦</p></li> <li><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//最简单方式是取得纯文本格式的内容，这要用到 text()方法。这个方法返回一个promise，会解决为取得资源的完整内容：</span>
<span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'bar.txt'</span><span class="token punctuation">)</span>
 <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
 	response<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
 		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
 	<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

<span class="token comment">// 内容的结构通常是打平的：</span>
<span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'bar.txt'</span><span class="token punctuation">)</span>
 <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> response<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li> <li><p>处理状态码和请求失败</p> <ul><li>response.status // 200 404  500</li> <li>response.statusText // OK    Not Found    Internal Server Error</li></ul></li> <li><p>自定义选项：fetch(url, 自定义对象)</p></li></ul> <table><thead><tr><th>键</th> <th>值</th></tr></thead> <tbody><tr><td>body</td> <td>指定使用请求体时请求体的内容 必须是 Blob、BufferSource、FormData、URLSearchParams、ReadableStream 或 String 的 实例</td></tr> <tr><td>cache</td> <td>用于控制浏览器与 HTTP缓存的交互。要跟踪缓存的重定向，请求的 redirect 属性值必须是&quot;follow&quot;， 而且必须符合同源策略限制。必须是下列值之一：Default、no-store、reload、no-cache、force-cache、only-if-cached</td></tr> <tr><td>credentials</td> <td>用于指定在外发请求中如何包含 cookie。omit、same-origin、include</td></tr> <tr><td>header</td> <td>用于指定请求头部</td></tr> <tr><td>integrity</td> <td>用于强制子资源完整性</td></tr> <tr><td>keepalive</td> <td>用于指示浏览器允许请求存在时间超出页面生命周期</td></tr> <tr><td>method</td> <td>用于指定 HTTP 请求方法, 默认为 GET</td></tr> <tr><td>mode</td> <td>用于指定请求模式：cors、no-cors、same-origin、navigate</td></tr> <tr><td>redirect</td> <td>用于指定如何处理重定向响应（状态码为 301、302、303、307 或 308）</td></tr> <tr><td>referrer</td> <td>用于指定 HTTP 的 Referer 头部的内容</td></tr> <tr><td>referrerPolicy</td> <td>用于指定 HTTP 的 Referer 头部</td></tr> <tr><td>signal</td> <td>用于支持通过 AbortController 中断进行中的 fetch()请求</td></tr></tbody></table></li> <li><p>常见Fetch请求模式</p> <ul><li>发送JSON数据</li> <li>在请求体中发送参数</li> <li>发送文件，formData</li> <li>加载Blob文件</li> <li>发送跨源请求</li> <li>中断请求</li></ul></li> <li><p>Headers对象</p> <ul><li>set</li> <li>has</li> <li>get</li> <li>delete</li> <li>append</li> <li>头部护卫</li></ul></li> <li><p>Request对象</p> <ul><li>fetch()和 Request 构造函数拥有相同的函数签名并不是巧合。在调用 fetch()时，可以传入已 经创建好的 Request 实例而不是 URL。</li> <li>关键在于，通过 fetch 使用 Request 会将请求体标记为已使用。也就是说，有请求体的 Request 只能在一次 fetch 中使用</li></ul></li> <li><p>Response对象</p></li></ul> <h4 id="beacon-api"><a href="#beacon-api" class="header-anchor">#</a> Beacon API</h4> <ul><li>给 navigator 对象增加了一个 sendBeacon()方法。这个简单的方法接收一个 URL 和一个数据有效载荷参数，并会发送一个 POST 请求</li> <li>通过浏览器的 unload 事件发送网络请求</li></ul> <h4 id="web-socket"><a href="#web-socket" class="header-anchor">#</a> Web Socket</h4> <ul><li><p>长时连接实现与服务器全双工、双向的通信</p></li> <li><p>以初始化连接，服务器响应后，连接使用 HTTP 的 Upgrade 头部从 HTTP 协议切换到 Web Socket 协议</p></li> <li><p>优缺点</p> <ul><li>使用自定义协议而非 HTTP 协议的好处是，客户端与服务器之间可以发送非常少的数据，不会对 HTTP 造成任何负担。使用更小的数据包让 Web Socket 非常适合带宽和延迟问题比较明显的移动应用。</li> <li>缺点是，定义协议的时间比定义 JavaScript API 要长。</li></ul></li> <li><p>API</p> <ul><li>实例化
<ul><li>let socket = new WebSocket(&quot;ws://www.example.com/server.php&quot;);</li> <li>readyState 属性表示当前状态
<ul><li>WebSocket.OPENING（0）：连接正在建立</li> <li>WebSocket.OPEN（1）：连接已经建立</li> <li>WebSocket.CLOSING（2）：连接正在关闭</li> <li>WebSocket.CLOSE（3）：连接已经关闭</li></ul></li></ul></li></ul></li> <li><p>发送和接收数据</p> <ul><li>send(个字符串、ArrayBuffer 或 Blob)</li> <li>服务器向客户端发送消息时，WebSocket 对象上会触发 message 事件:</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code>socket<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">let</span> data <span class="token operator">=</span> event<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
 <span class="token comment">// 对数据执行某些操作</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
</code></pre></div></li> <li><p>其它事件</p> <ul><li>open</li> <li>error</li> <li>close</li></ul></li></ul> <h4 id="安全"><a href="#安全" class="header-anchor">#</a> 安全</h4> <ul><li>跨站点请求伪造（CSRF，cross-site request forgery）
<ul><li>未授权系统可以访问某个资源时</li> <li>预防：要验证请求发送者拥有对资源的访问权限
<ul><li>SSL 访问</li> <li>token</li></ul></li></ul></li></ul> <h3 id="二十五、客户端存储"><a href="#二十五、客户端存储" class="header-anchor">#</a> 二十五、客户端存储</h3> <h4 id="cookie"><a href="#cookie" class="header-anchor">#</a> cookie</h4> <ul><li>限制
<ul><li>绑定域</li> <li>不超过300个cookie（非必须）</li> <li>每个cookie不超过4096字节</li> <li>每个域不超过20个cookie</li> <li>每个域不超过81920字节</li></ul></li> <li>构成。这些参数在 Set-Cookie 头部中使用分号加空格隔开
<ul><li>名称</li> <li>值</li> <li>域</li> <li>路径</li> <li>过期时间</li> <li>安全标志</li></ul></li> <li>JavaScript 中的 cookie
<ul><li>接口过于简单，只有 BOM 的 document.cookie 属性</li></ul></li> <li>子cookie</li> <li>注意事项
<ul><li>HTTP-only 的 cookie，可以在浏览器设置，也可以在服务器设置，只能在服务器上读取</li> <li>对 cookie 的限制及其特性决定了 cookie 并不是存储大量数据的理想方式</li></ul></li></ul> <h4 id="web-storage"><a href="#web-storage" class="header-anchor">#</a> Web Storage</h4> <ul><li><p>Storage 类型</p> <ul><li>clear()</li> <li>getItem(name)</li> <li>key(index)</li> <li>removeItem(name)</li> <li>setItem(name, value)</li></ul></li> <li><p>sessionStorage</p> <ul><li>着数据只会存储到浏览器关闭</li> <li>在运行本地文件时不能使用。</li> <li>据只能由最初存储数据的页面使用，在多页应用程序中的用处有限</li></ul></li> <li><p>localStorage</p> <ul><li>在客户端持久存储 数据的机制</li> <li>要访问同一个 localStorage 对象，页面必须来自<strong>同一个域</strong>（子域不可以）、在<strong>相同的端口</strong>上使用相同的协议</li> <li>据会保留到通过 JavaScript 删除或者用户 清除浏览器缓存</li></ul></li> <li><p>存储事件</p> <ul><li><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 可以使用如下代码监听 storage 事件：</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;storage&quot;</span><span class="token punctuation">,</span>
 <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Storage changed for ${event.domain}'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li> <li><p>限制</p> <ul><li>不同浏览器给 localStorage 和 sessionStorage 设置了不同的空间限制，但大多数会限制为每 个源 5MB</li></ul></li></ul> <h4 id="indexeddb"><a href="#indexeddb" class="header-anchor">#</a> IndexedDB</h4> <ul><li>数据库
<ul><li>是类似于 MySQL 或 Web SQL Database 的数据库</li> <li>与传统数据库最大的区别在于， IndexedDB 使用对象存储而不是表格保存数据</li></ul></li> <li>对象存储</li> <li>事务</li> <li>插入对象</li> <li>游标查询</li> <li>键范围</li> <li>设置游标方向</li> <li>索引</li> <li>并发问题</li> <li>限制</li></ul> <h3 id="二十六、模块"><a href="#二十六、模块" class="header-anchor">#</a> 二十六、模块</h3> <p>模块系统本质上是键/值实体</p> <ul><li><p>理解模块模式</p> <ul><li>模块标识符
<ul><li>原生浏览器模块标识符必须 提供实际 JavaScript 文件的路径</li> <li>除了文件路径，Node.js 还会搜索 node_modules 目录，用标识符去匹配 包含 index.js 的目录</li></ul></li> <li>模块依赖</li> <li>模块加载</li> <li>入口</li> <li>异步加载</li> <li>动态依赖</li> <li>静态分析</li> <li>循环依赖</li></ul></li> <li><p>凑合的模块系统</p></li> <li><p>使用ES6之前的模块加载器</p> <p>在 ES6 原生支持模块之前，使用模块的 JavaScript 代码本质上是希望使用默认没有的语言特性</p> <ul><li>CommonJS规范概述了同步声明依赖的模块定义。
<ul><li>以服务器端为目标环境，能够一次性把所有模块都加载到内存</li> <li>CommonJS 模块语法不能在浏览器中直接运行。</li> <li>CommonJS 模块定义需要使用 require()指定依赖，而使用 exports 对象定义自己的公共 API。</li></ul></li> <li>异步模块定义（AMD， Asynchronous Module Definition）
<ul><li>以浏览器为目标执行环境，这需要考虑网络延迟的 问题</li> <li>AMD 也支持 require 和 exports 对象</li></ul></li> <li>通用模块定义（UMD，Universal Module Definition）
<ul><li>为了统一 CommonJS 和 AMD 生态系统</li></ul></li> <li>模块加载器终将没落</li></ul></li> <li><p>使用ES6模块</p> <ul><li>模块标签及定义</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">&quot;module&quot;</span><span class="token operator">&gt;</span>
 <span class="token comment">// 模块代码</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">&quot;module&quot;</span> src<span class="token operator">=</span><span class="token string">&quot;path/to/myModule.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><ul><li>与传统脚本不同，所有模块都会像&lt;script defer&gt;加载的脚本一样按顺序执行。解析到标签后会立即下载模块文件，但执行会延迟到文档解析完成。</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 第二个执行 <span class="token operator">--</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">&quot;module&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 第三个执行 <span class="token operator">--</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">&quot;module&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 第一个执行 <span class="token operator">--</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span> 
</code></pre></div><ul><li>模块加载。ECMAScript 6 模块的独特之处在于，既可以通过浏览器原生加载，也可以与第三方加载器和构建工 具一起加载。</li> <li>模块行为
<ul><li>模块代码只在加载后执行。</li> <li>模块只能加载一次。</li> <li>模块是单例。</li> <li>模块可以定义公共接口，其他模块可以基于这个公共接口观察和交互。</li> <li>模块可以请求加载其他模块。</li> <li>支持循环依赖。</li> <li>ES6 模块默认在严格模式下执行。</li> <li>ES6 模块不共享全局命名空间。</li> <li>模块顶级 this 的值是 undefined（常规脚本中是 window）。</li> <li>模块中的 var 声明不会添加到 window 对象。</li> <li>ES6 模块是异步加载和执行的。</li></ul></li> <li>模块导出
<ul><li>export:导出语句必须在模块顶级，不能嵌套在某个块中</li> <li>命名导出</li> <li>默认导出</li></ul></li> <li>模块导入
<ul><li>import</li></ul></li> <li>模块转移导出</li> <li>工作者模块</li> <li>向后兼容
<ul><li>可以使用第三方模块系统（如 SystemJS）或在构建时 将 ES6 模块进行转译</li> <li>提供两个版本的代码, 不推荐</li></ul></li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 支持模块的浏览器会执行这段脚本</span>
<span class="token comment">// 不支持模块的浏览器不会执行这段脚本</span>
<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">&quot;module&quot;</span> src<span class="token operator">=</span><span class="token string">&quot;module.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token comment">// 支持模块的浏览器不会执行这段脚本</span>
<span class="token comment">// 不支持模块的浏览器会执行这段脚本</span>
<span class="token operator">&lt;</span>script nomodule src<span class="token operator">=</span><span class="token string">&quot;script.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div></li></ul> <h3 id="二十七、工作者线程"><a href="#二十七、工作者线程" class="header-anchor">#</a> 二十七、工作者线程</h3> <ul><li>工作者线程简介</li> <li>专用工作者线程</li> <li>共享工作者线程</li> <li>服务工作者线程</li></ul> <h3 id="二十八、最佳实践"><a href="#二十八、最佳实践" class="header-anchor">#</a> 二十八、最佳实践</h3> <h4 id="可维护性"><a href="#可维护性" class="header-anchor">#</a> 可维护性</h4> <h4 id="性能"><a href="#性能" class="header-anchor">#</a> 性能</h4> <ul><li>作用域意识
<ul><li>避免全局查找</li> <li>不适用with语句</li></ul></li> <li>选择正确的方法
<ul><li>避免不必要的属性查找</li> <li>优化循环</li> <li>展开循环</li> <li>避免重复解释</li> <li>尽可能使用原生方法、switch语句、位操作</li></ul></li> <li>语句最少化</li> <li>优化DOM交互
<ul><li>实时更新最小化</li> <li>事件委托</li> <li>注意HTMLCollection</li></ul></li></ul> <h4 id="部署"><a href="#部署" class="header-anchor">#</a> 部署</h4> <ul><li><p>构建流程</p> <ul><li><p>知识产权问题、删掉注释，文件大小、代码组织</p></li> <li><p>文件结构</p></li> <li><p>任务运行器</p></li> <li><p>摇树优化</p></li> <li><p>模块打包器</p> <ul><li>以模块形式编写代码，并不意味着必须以模块形式交付代码。通常，由大量模块组成的 JavaScript 代码在构建时需要打包到一起，然后只交付一个或少数几个 JavaScript 文件。</li> <li>Webpack、Rollupt 和 Browserify...</li></ul></li></ul></li> <li><p>验证</p> <ul><li>eslint</li></ul></li> <li><p>压缩</p> <ul><li>代码压缩。构建流程...</li> <li>Javascript编译</li> <li>Js转译</li> <li>HTTP压缩</li></ul></li></ul></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/kake-blog/" class="prev router-link-active">
          学前必读
        </a></span> <span class="next"><a href="/kake-blog/js/原型和原型链.html">
          原型和原型链
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#一、介绍" class="sidebar-link reco-side-一、介绍" data-v-b57cc07c>一、介绍</a></li><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#二、html中的js" class="sidebar-link reco-side-二、html中的js" data-v-b57cc07c>二、HTML中的Js</a></li><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#三、语言基础" class="sidebar-link reco-side-三、语言基础" data-v-b57cc07c>三、语言基础</a></li><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#四、变量、作用域与内存" class="sidebar-link reco-side-四、变量、作用域与内存" data-v-b57cc07c>四、变量、作用域与内存</a></li><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#五、基本引用类型" class="sidebar-link reco-side-五、基本引用类型" data-v-b57cc07c>五、基本引用类型</a></li><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#六、集合引用类型" class="sidebar-link reco-side-六、集合引用类型" data-v-b57cc07c>六、集合引用类型</a></li><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#七、迭代器与生成器" class="sidebar-link reco-side-七、迭代器与生成器" data-v-b57cc07c>七、迭代器与生成器</a></li><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#八、对象、类与面向对象编程" class="sidebar-link reco-side-八、对象、类与面向对象编程" data-v-b57cc07c>八、对象、类与面向对象编程</a></li><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#九、代理和反射" class="sidebar-link reco-side-九、代理和反射" data-v-b57cc07c>九、代理和反射</a></li><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#十、函数" class="sidebar-link reco-side-十、函数" data-v-b57cc07c>十、函数</a></li><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#十一、期约与异步函数" class="sidebar-link reco-side-十一、期约与异步函数" data-v-b57cc07c>十一、期约与异步函数</a></li><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#十二、bom" class="sidebar-link reco-side-十二、bom" data-v-b57cc07c>十二、BOM</a></li><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#十三、客户端检测" class="sidebar-link reco-side-十三、客户端检测" data-v-b57cc07c>十三、客户端检测</a></li><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#十四、dom" class="sidebar-link reco-side-十四、dom" data-v-b57cc07c>十四、DOM</a></li><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#十五、dom扩展" class="sidebar-link reco-side-十五、dom扩展" data-v-b57cc07c>十五、DOM扩展</a></li><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#十六、dom2和dom3" class="sidebar-link reco-side-十六、dom2和dom3" data-v-b57cc07c>十六、DOM2和DOM3</a></li><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#十七、事件" class="sidebar-link reco-side-十七、事件" data-v-b57cc07c>十七、事件</a></li><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#十八、动画与canvas图形" class="sidebar-link reco-side-十八、动画与canvas图形" data-v-b57cc07c>十八、动画与Canvas图形</a></li><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#十九、表单脚本" class="sidebar-link reco-side-十九、表单脚本" data-v-b57cc07c>十九、表单脚本</a></li><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#二十、javascript-api" class="sidebar-link reco-side-二十、javascript-api" data-v-b57cc07c>二十、JavaScript API</a></li><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#二十一、错误处理与调试" class="sidebar-link reco-side-二十一、错误处理与调试" data-v-b57cc07c>二十一、错误处理与调试</a></li><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#二十二、处理xml" class="sidebar-link reco-side-二十二、处理xml" data-v-b57cc07c>二十二、处理XML</a></li><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#二十三、json" class="sidebar-link reco-side-二十三、json" data-v-b57cc07c>二十三、JSON</a></li><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#二十四、网络请求与远程资源" class="sidebar-link reco-side-二十四、网络请求与远程资源" data-v-b57cc07c>二十四、网络请求与远程资源</a></li><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#二十五、客户端存储" class="sidebar-link reco-side-二十五、客户端存储" data-v-b57cc07c>二十五、客户端存储</a></li><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#二十六、模块" class="sidebar-link reco-side-二十六、模块" data-v-b57cc07c>二十六、模块</a></li><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#二十七、工作者线程" class="sidebar-link reco-side-二十七、工作者线程" data-v-b57cc07c>二十七、工作者线程</a></li><li class="level-3" data-v-b57cc07c><a href="/kake-blog/js/JavaScript%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%94%E8%AE%B0.html#二十八、最佳实践" class="sidebar-link reco-side-二十八、最佳实践" data-v-b57cc07c>二十八、最佳实践</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/kake-blog/assets/js/app.ba41769d.js" defer></script><script src="/kake-blog/assets/js/3.e126f458.js" defer></script><script src="/kake-blog/assets/js/1.f474e8b5.js" defer></script><script src="/kake-blog/assets/js/16.3ad6af45.js" defer></script>
  </body>
</html>
